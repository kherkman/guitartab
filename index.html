<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics-Based Fretboard & Chord/Scale Library</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #333; color: #f0f0f0; display: flex; justify-content: center; align-items: center; flex-direction: column; margin: 0; padding: 20px; user-select: none; }
        #app { background-color: #444; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); width: 98%; max-width: 1400px; }
        h1 { text-align: center; margin-top: 0; color: #e0a800; }
        .controls { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 25px; background-color: #2c2c2c; padding: 10px; border-radius: 8px; }
        .control-section { background-color: #3a3a3a; padding: 12px; border-radius: 6px; border: 1px solid #555; display: flex; flex-direction: column; gap: 12px; align-items: flex-start; }
        .control-section h4 { margin: 0 0 5px 0; color: #ccc; font-weight: normal; border-bottom: 1px solid #555; width: 100%; padding-bottom: 5px; }
        .control-section-theory { border-left: 4px solid #4a90e2; }
        .control-section-instrument { border-left: 4px solid #f5a623; }
        .control-section-view { border-left: 4px solid #7ed321; }
        .control-group { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .control-group label { font-weight: bold; }
        button, select { padding: 8px 15px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; background-color: #e0a800; color: #333; font-weight: bold; transition: background-color 0.2s; }
        button:hover, select:hover { background-color: #ffc107; }
        button:disabled { background-color: #666; cursor: not-allowed; }
        .theory-display-container { display: flex; flex-direction: column; align-items: center; gap: 5px; margin-top: 15px; min-height: 48px; font-size: 1.1em; }
        .active-theory-display { font-weight: bold; color: #ffc107; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        .recognition-display { font-weight: bold; color: #ccc; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; font-size: 0.9em; font-style: italic; }
        .recognition-display span.clickable { cursor: pointer; background-color: #555; padding: 3px 8px; border-radius: 4px; transition: background-color 0.2s; }
        .recognition-display span.clickable:hover { background-color: #666; color: #ffc107; }
        #main-layout { display: grid; transition: grid-template-columns 0.3s ease-in-out; }
        #string-controls-container, #fretboard-container { display: flex; flex-direction: column; gap: 6px; }
        #fretboard-scroll-container { overflow-x: auto; padding-bottom: 15px; background: #3a3a3a; border-radius: 5px; margin-top: 10px; }
        #fretboard-wrapper { min-width: 100%; transition: width 0.2s, transform 0.3s; }
        .string-control-panel { background: #3a3a3a; border-radius: 5px; padding: 5px 10px; height: 25px; display: flex; align-items: center; gap: 8px; font-size: 0.8em; transition: width 0.3s ease-in-out; }
        .input-group { display: flex; align-items: center; gap: 4px; }
        .input-group input, #scale-search-input { background: #555; color: #fff; border: 1px solid #777; border-radius: 3px; padding: 4px; box-sizing: border-box; text-align: center; }
        input[id^="len-"], input[id^="ten-"] { width: 50px; }
        input[id^="wid-"] { width: 60px; }
        .info-display { margin-left: auto; display: flex; align-items: center; gap: 15px; font-weight: bold; color: #ffc107; white-space: nowrap; }
        .remove-string-btn { background-color: #dc3545; color: white; padding: 0; width: 20px; height: 20px; line-height: 20px; border-radius: 50%; font-size: 14px; margin-left: 10px; }
        .remove-string-btn:hover { background-color: #c82333; }
        #fretboard-outer-container { background-color: #8B4513; border: 2px solid #222; border-radius: 5px; padding: 20px 10px; box-shadow: inset 0 0 20px rgba(0,0,0,0.4); }
        #fret-numbers-container { display: flex; height: 20px; margin-bottom: 5px; }
        .fret-number { display: flex; justify-content: center; align-items: center; color: #ffc107; font-weight: bold; font-size: 0.9em; }
        .string-row { position: relative; display: flex; width: 100%; height: 25px; transition: width 0.3s ease-in-out; }
        .string-row::before { content: ''; position: absolute; width: 100%; height: var(--string-thickness, 2px); background: linear-gradient(to bottom, #e8e8e8, #b0b0b0); top: 50%; left: 0; transform: translateY(-50%); z-index: 1; border-radius: 2px; box-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .fret-space { height: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
        .fret-space.note-active::after, .fret-space.tab-playing::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 193, 7, 0.5); border-radius: 3px; z-index: 2; pointer-events: none; }
        .fret-space.note-playing::after { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: rgba(74, 144, 226, 0.6); border: 2px solid #fff; border-radius: 5px; z-index: 3; pointer-events: none; animation: note-play-pulse 0.3s ease-out; }
        @keyframes note-play-pulse { 0% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 0.7; } }
        .fret-divider { position: absolute; top: -5px; bottom: -5px; width: 4px; background-color: #aaa; z-index: 5; transform: translateX(-50%); border-left: 1px solid #777; border-right: 1px solid #777; }
        .open-string-space { width: 50px; flex-shrink: 0; background-color: rgba(0,0,0,0.1); }
        .fretted-area { flex: 1; display: flex; position: relative; border-left: 8px solid #f0f0f0; }
        .note { position: absolute; top: 50%; width: 28px; height: 22px; line-height: 22px; background: radial-gradient(circle at 30% 30%, #4a90e2, #245a9e); border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.5); z-index: 10; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); padding: 0 2px; }
        #zoom-slider-container { display: flex; align-items: center; gap: 10px; margin-top: 10px; justify-content: center; }
        #zoom-slider, #master-volume-slider { width: 200px; }
        #circle-of-fifths-container, #scale-modes-container { margin-top: 25px; display: flex; flex-direction: column; align-items: center; }
        #cof-svg { cursor: default; }
        #cof-svg .cof-note-group { cursor: pointer; }
        #cof-svg .cof-note-circle { fill: #555; stroke: #888; stroke-width: 2; transition: fill 0.3s; }
        #cof-svg .cof-note-circle.highlight { fill: #e0a800; }
        #cof-svg .cof-note-text { font-size: 16px; font-weight: bold; fill: #fff; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        #cof-svg .cof-roman-text { font-size: 12px; fill: #333; font-weight: bold; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        #cof-svg #cof-lock-btn { cursor: pointer; }
        #cof-svg #cof-lock-btn circle { transition: fill 0.2s; }
        #cof-svg #cof-lock-btn circle.locked { fill: #e0a800; }
        #cof-svg #cof-lock-btn text { pointer-events: none; }
        #scale-modes-list { list-style: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        .mode-item { display: flex; align-items: center; gap: 10px; background: #3a3a3a; padding: 8px 12px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; width: 320px; text-align: left; border: 1px solid #555; }
        .mode-item:hover { background-color: #555; border-color: #777; }
        .mode-text-container { flex-grow: 1; }
        .mode-name { font-weight: bold; color: #e0a800; font-size: 0.9em;}
        .mode-steps { font-family: monospace; font-size: 0.9em; color: #ccc; margin-top: 4px; }
        .comments { margin-top: 20px; background: #2c2c2c; padding: 10px 15px; border-radius: 5px; font-size: 0.9em; text-align: left; }
        .comments h3 { margin-top: 0; color: #e0a800; }
        .comments h4 { margin-top: 5px; margin-bottom: 5px; color: #ccc; }
        .comments ul { padding-left: 20px; margin: 0; }
        .comments p { margin: 5px 0; }
        .comments a { color: #e0a800; text-decoration: none; }
        .comments a:hover { text-decoration: underline; }
        .comments code { background: #555; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        /* Left-Handed View Styles */
        #fretboard-wrapper.left-handed { transform: scaleX(-1); }
        #fretboard-wrapper.left-handed .fret-number { transform: scaleX(-1); }
        #fretboard-wrapper.left-handed .note { transform: translate(-50%, -50%) scaleX(-1); }

        /* Cursor styles for interaction modes */
        #fretboard-container.mode-toggle_note .fret-space, #fretboard-container.mode-toggle_note .note { cursor: pointer; }
        #fretboard-container.mode-insert .fret-space, #fretboard-container.mode-insert .note { cursor: crosshair; }
        #fretboard-container.mode-remove .fret-space, #fretboard-container.mode-remove .note { cursor: not-allowed; }
        #fretboard-container.mode-play .fret-space, #fretboard-container.mode-play .note { cursor: pointer; }
        #fretboard-container.mode-move_fret .fret-space { cursor: default; }
        #fretboard-container.mode-move_fret .fret-divider { cursor: col-resize; }

        /* --- Tab Editor Styles --- */
        #tab-editor-container { margin-top: 25px; background-color: #2c2c2c; padding: 15px; border-radius: 8px; width: 100%; box-sizing: border-box; }
        #tab-editor-container h3 { margin-top: 0; color: #e0a800; text-align: center; }
        .tab-controls { display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; }
        .tab-controls .control-group { background: #3a3a3a; padding: 5px 10px; border-radius: 5px; }
        .tab-controls input[type="number"] { width: 60px; background: #555; color: #fff; border: 1px solid #777; border-radius: 3px; padding: 4px; text-align: center; }
        #tab-grid-wrapper { overflow-x: auto; background-color: #3a3a3a; padding: 10px; border-radius: 5px; position: relative; }
        #tab-grid { display: grid; font-family: monospace; font-size: 1.1em; }
        .tab-row { display: flex; align-items: center; border-bottom: 1px solid #555; }
        .tab-row:last-child { border-bottom: none; }
        .tab-string-name { font-weight: bold; color: #e0a800; padding: 0 10px; }
        .tab-cell { background-color: transparent; color: #f0f0f0; border: none; font-family: inherit; font-size: inherit; text-align: center; width: 2.2ch; padding: 4px 0; border-radius: 3px; transition: background-color 0.2s; }
        .tab-cell:focus { background-color: #555; outline: 1px solid #e0a800; }
        #tab-playhead { position: absolute; top: 0; bottom: 0; width: 2.2ch; background-color: rgba(224, 168, 0, 0.4); border-left: 2px solid #e0a800; pointer-events: none; transition: transform 0.05s linear; z-index: 100; }
        .tab-io-section { margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        #text-tab-io { width: 100%; height: 150px; background: #555; color: #fff; border: 1px solid #777; border-radius: 5px; font-family: monospace; padding: 10px; box-sizing: border-box; resize: vertical; }
        .tab-io-controls { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
        #midi-file-input { display: none; }
        #midi-file-label { display: inline-block; padding: 8px 15px; background-color: #e0a800; color: #333; font-weight: bold; border-radius: 5px; cursor: pointer; }
        #midi-file-label:hover { background-color: #ffc107; }

        /* Scale Search Input */
        .scale-select-container { display: flex; flex-direction: column; gap: 5px; }
        #scale-search-input { width: 100%; text-align: left; padding-left: 8px; }
        #scale-type-select { width: 100%; height: 120px; padding: 5px; } /* Use size attribute in HTML instead of height for consistency */
        #scale-type-select option { padding: 4px; }

    </style>
</head>
<body>
    <div id="app">
        <h1>Physics-Based Fretboard & Chord/Scale Library</h1>
        <div class="controls">
            <div class="control-section control-section-theory">
                <h4>Music Theory</h4>
                <div class="control-group"><label>Root Note:</label><select id="root-note-select"></select></div>
                <div class="control-group"><label>Chord:</label><select id="chord-type-select"></select><button id="show-chord-btn">Show</button><button id="clear-fretboard-btn">Clear</button></div>
                <div class="scale-select-container">
                    <label>Scale:</label>
                    <input type="text" id="scale-search-input" placeholder="Search scales...">
                    <select id="scale-type-select" size="5"></select>
                </div>
                <div class="control-group">
                    <button id="show-scale-btn">Show</button><button id="random-scale-btn">Random</button><select id="notes-per-string-select"><option value="all">All Scale Notes</option><option value="3">3 per String</option><option value="4">4 per String</option></select>
                </div>
                <div class="control-group"><button id="toggle-scale-set-btn">Show Zeitler Scales</button></div>
            </div>
            <div class="control-section control-section-instrument">
                <h4>Instrument</h4>
                <div class="control-group"><label for="setup-select">Presets:</label><select id="setup-select"><option value="" disabled selected>Select...</option><option value="guitar">Standard Guitar</option><option value="bass">Standard Bass</option><option value="ukulele">Standard Ukulele</option><option value="drop_d">Drop D</option><option value="open_g">Open G</option><option value="dadgad">DADGAD</option><option value="7_string">7-String Guitar</option><option value="8_string">8-String Guitar</option><option value="just_intonation">Just Intonation</option><option value="true_temperament">True Temperament</option><option value="19_edo">19-EDO</option><option value="24_edo">24-EDO (Quarter-tone)</option><option value="31_edo">31-EDO</option><option value="kantele_5_major">5-Str Kantele (Major)</option><option value="kantele_5_minor">5-Str Kantele (Minor)</option><option value="kantele_11">11-Str Kantele</option><option value="overtone">Overtone Series Demo</option></select></div>
                <div class="control-group"><label>Strings:</label><button id="add-low-string">Add Low</button><button id="add-high-string">Add High</button></div>
                <div class="control-group"><label>Frets:</label><button id="remove-fret">-</button><span id="fret-count">12</span><button id="add-fret">+</button></div>
                <div class="control-group"><label>MIDI In:</label><select id="midi-in-select"><option value="">None</option></select><label>Out:</label><select id="midi-out-select"><option value="">None</option></select></div>
                <div class="control-group"><button id="toggle-tuning-panel">Hide Tuning</button><button id="reverse-strings-btn">Spectator View</button><button id="left-handed-btn">Left Handed</button><button id="reset-frets">Reset Instrument</button></div>
            </div>
            <div class="control-section control-section-view">
                <h4>Display & View</h4>
                <div class="control-group">
                    <label>Edit/Play Mode:</label>
                    <select id="edit-play-mode">
                        <option value="toggle_note" selected>Insert/Remove A Note</option>
                        <option value="insert">Insert A Note</option>
                        <option value="remove">Remove A Note</option>
                        <option value="play">Play A Note</option>
                        <option value="move_fret">Move A Fret</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Sound Type:</label>
                    <select id="sound-type-select">
                        <option value="acoustic" selected>Acoustic</option>
                        <option value="distortion">Distortion</option>
                    </select>
                </div>
                <div class="control-group"><label>Note Display:</label><select id="display-mode"><option value="names">Note Names</option><option value="frequencies">Frequencies</option><option value="intervals">Intervals</option><option value="intervals_roman">Intervals (Roman)</option><option value="fingerings">Fingerings</option><option value="cents">Cents</option></select></div>
                <div class="control-group"><label>Volume:</label><input type="range" id="master-volume-slider" min="0" max="100" value="80"></div>
                <div class="control-group"><button id="show-fret-numbers-btn">Hide Fret #</button><button id="show-all-notes-btn">Show All Notes</button></div>
                <div class="control-group"><button id="play-strum-btn">Play Strum</button><button id="play-shred-btn">Play Shred</button></div>
            </div>
        </div>
        <div id="main-layout">
            <div id="string-controls-container"></div>
            <div id="fretboard-main-area">
                <div id="fretboard-outer-container">
                    <div id="fretboard-scroll-container">
                        <div id="fretboard-wrapper">
                            <div id="fret-numbers-container"></div>
                            <div id="fretboard-container"></div>
                        </div>
                    </div>
                </div>
                <div id="zoom-slider-container">
                    <label for="zoom-slider">Zoom:</label>
                    <input type="range" id="zoom-slider" min="0" max="100" value="0">
                </div>
                <div class="theory-display-container">
                    <div class="active-theory-display">
                        <span id="current-root-display"></span>
                        <span id="current-notes-display"></span>
                    </div>
                    <div class="recognition-display">
                        <span id="recognized-chord-display"></span>
                        <span id="recognized-scale-display"></span>
                    </div>
                </div>
            </div>
        </div>
        <div id="circle-of-fifths-container">
             <h3>12 EDO Circle of Fifths</h3>
             <svg id="cof-svg" width="300" height="300">
                <g id="cof-lock-btn">
                    <circle cx="150" cy="150" r="30" fill="#666" stroke="#888" stroke-width="2"></circle>
                    <text id="cof-lock-icon" x="150" y="150" font-size="24" text-anchor="middle" dominant-baseline="central" fill="#fff">üîì</text>
                </g>
             </svg>
        </div>
        <div id="scale-modes-container" style="display: none;">
            <h3>Scale Modes</h3>
            <ul id="scale-modes-list"></ul>
        </div>
        
        <!-- --- TAB EDITOR SECTION --- -->
        <div id="tab-editor-container">
            <h3>Tablature Editor & Player</h3>
            <div class="tab-controls">
                <div class="control-group">
                    <button id="play-tab-btn">‚ñ∂ Play</button>
                    <button id="stop-tab-btn">‚ñ† Stop</button>
                </div>
                <div class="control-group">
                    <label for="tempo-input">Tempo (BPM):</label>
                    <input type="number" id="tempo-input" value="120" min="20" max="300">
                </div>
                <div class="control-group">
                    <label>Columns:</label>
                    <button id="remove-tab-col-btn" title="Remove last column">-</button>
                    <button id="add-tab-col-btn" title="Add new column">+</button>
                </div>
            </div>
            <div id="tab-grid-wrapper">
                <div id="tab-grid"></div>
                <div id="tab-playhead" style="display: none;"></div>
            </div>
            <div class="tab-io-section">
                <textarea id="text-tab-io" placeholder="Paste text tablature here... or export to here."></textarea>
                <div class="tab-io-controls">
                    <button id="import-text-tab-btn">Import from Text</button>
                    <button id="export-text-tab-btn">Export to Text</button>
                    <button id="export-midi-btn">Export to MIDI</button>
                    <label for="midi-file-input" id="midi-file-label">Import from MIDI</label>
                    <input type="file" id="midi-file-input" accept=".mid,.midi">
                </div>
            </div>
        </div>
        <!-- --- END TAB EDITOR SECTION --- -->

        <div class="comments"><h3>How To Use</h3><ul><li><strong>Contextual Info:</strong> Selecting some presets like "Overtone Series Demo" will show a special information panel below.</li><li><strong>Scale Libraries:</strong> Use the "Show Zeitler Scales" button to switch between the basic scale list and a massive library of over 2000 scales.</li><li><strong>Tab Playback:</strong> Press the <strong>Spacebar</strong> to play or pause the tablature sequence.</li><li><strong>Circle of Fifths:</strong> Click a chord to view it. Use the central üîí to lock the root while exploring the key.</li></ul></div>
        <div class="comments"><h3>Physics Formula</h3><p><code>frequency = (1 / (2 * L)) * sqrt(T / Œº)</code> where L=Length, T=Tension, Œº=Linear Density.</p><p>Linear Density <code>Œº = œÅ * (œÄ * (width/2)^2)</code> where œÅ=Material Density.</p></div>
        <div class="comments"><h3>Interval Calculation Formulas</h3><p><strong>Equal Divisions of the Octave (EDO):</strong> Divides the octave (a 2/1 frequency ratio) into N equal steps. The frequency for any step is calculated as <code>freq = baseFreq * 2^(step / N)</code>. Standard tuning is 12-EDO.</p><p><strong>Just Intonation (JI):</strong> Defines intervals by simple integer ratios, leading to pure-sounding consonances. The frequency for any interval is <code>freq = baseFreq * (p / q)</code>, e.g., a perfect fifth is 3/2.</p></div>
        <div class="comments" id="overtone-comments" style="display: none;">
            <h3>Overtone Series Explained</h3>
            <p>The ‚ÄúOvertone Series demo‚Äù visually demonstrates that frequency is inversely proportional to length (f ‚àù 1/L). At the same time the object is vibrating as a whole, it is also vibrating in smaller, faster sections. It vibrates in halves, in thirds, in fourths, and so on.</p>
            <p>Each of these smaller, faster vibrations produces a higher, quieter pitch. These additional pitches are the overtones.</p>
            <p>You can isolate an overtone on a guitar. If you lightly touch the string exactly at the 12th fret (its halfway point) and pluck it, you mute the fundamental and hear only the 1st overtone (2nd harmonic), which is a clear note one octave higher.</p>
            <p><strong>Timbre</strong> is the unique sound quality of an instrument, determined by its specific recipe of overtones. Any complex, repeating sound wave, <code>y(t)</code>, can be described as the sum of simple sine waves. Each sine wave represents one harmonic (the fundamental or an overtone).The general form of the formula is:</p>
            <p><code>y(t) = A‚ÇÄ sin(2œÄf‚ÇÄt + œÜ‚ÇÄ) + A‚ÇÅ sin(2œÄf‚ÇÅt + œÜ‚ÇÅ) + A‚ÇÇ sin(2œÄf‚ÇÇt + œÜ‚ÇÇ) + ...</code></p>
        </div>
        <div class="comments" id="zeitler-credit" style="display: none;">
            <h4>Scale Library Credit</h4>
            <p>When the "Show Zeitler Scales" option is active, the scale list is populated from a library of over 2000 scales, with names and structures by William Zeitler, as listed at <a href="http://allthescales.org" target="_blank" rel="noopener noreferrer">allthescales.org</a>.</p>
        </div>
    </div>
    
    <script src="voicings.js"></script>
    <script src="zeitler-scales.js"></script>
    <script src="tab-editor.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- AUDIO SYNTHESIS ---
            const AudioPlayer = (() => {
                let audioCtx;
                let masterGain;

                // --- Sample-based audio settings ---
                const SAMPLE_CONFIG = {
                    'acoustic': {
                        files: ['guitar-note-1.wav', 'guitar-note-2.wav', 'guitar-note-3.wav', 'guitar-note-4.wav'],
                        baseHz: 110.0 // All acoustic samples must have this base pitch
                    },
                    'distortion': {
                        files: ['distguitar-note-1.wav', 'distguitar-note-2.wav'], // Add more distortion samples here
                        baseHz: 110.0 // All distortion samples must have this base pitch
                    }
                };

                let audioBuffers = {}; // Will store loaded buffers, e.g., audioBuffers.acoustic = [buffer1, buffer2]
                let currentSoundType = 'acoustic';
                let isInitialized = false;
                let isLoading = false;

                async function init() {
                    if (isInitialized || isLoading) return;

                    isLoading = true;
                    if (!audioCtx) {
                        try {
                            audioCtx = new(window.AudioContext || window.webkitAudioContext)();
                            masterGain = audioCtx.createGain();
                            masterGain.connect(audioCtx.destination);
                            setVolume(state.masterVolume);
                        } catch (e) {
                            console.error("Could not create AudioContext.", e);
                            isLoading = false;
                            return;
                        }
                    }

                    console.log("Loading all sound sets...");
                    for (const type in SAMPLE_CONFIG) {
                        const config = SAMPLE_CONFIG[type];
                        audioBuffers[type] = []; // Initialize array for this type
                        
                        const loadPromises = config.files.map(async (file) => {
                            try {
                                const response = await fetch(file);
                                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                                const arrayBuffer = await response.arrayBuffer();
                                return await audioCtx.decodeAudioData(arrayBuffer);
                            } catch (error) {
                                console.warn(`Could not load or decode sample: ${file}. It will be skipped.`);
                                return null;
                            }
                        });

                        const loaded = await Promise.all(loadPromises);
                        audioBuffers[type] = loaded.filter(b => b !== null); // Store only successfully loaded buffers

                        if (audioBuffers[type].length > 0) {
                            console.log(`Loaded ${audioBuffers[type].length}/${config.files.length} samples for '${type}' sound.`);
                        } else {
                            console.warn(`No samples loaded for '${type}' sound. It will fall back to synth.`);
                        }
                    }
                    
                    isInitialized = true;
                    isLoading = false;
                    console.log("Audio loading complete.");
                }

                function playNoteSynth(frequency, time) {
                    if (!audioCtx || frequency <= 0) return;
                    const now = audioCtx.currentTime;
                    const startTime = now + time;
                    const gain = 0.3;
                    const envelope = audioCtx.createGain();
                    envelope.connect(masterGain);
                    envelope.gain.setValueAtTime(0, startTime);
                    envelope.gain.linearRampToValueAtTime(gain, startTime + 0.02);
                    envelope.gain.exponentialRampToValueAtTime(gain * 0.5, startTime + 0.2);
                    envelope.gain.exponentialRampToValueAtTime(0.0001, startTime + 1.5);
                    const osc1 = audioCtx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = frequency; osc1.connect(envelope);
                    [2, 3, 4].forEach((multiple, i) => { const osc = audioCtx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = frequency * multiple; const oscGain = audioCtx.createGain(); oscGain.gain.value = gain / (multiple + i * 2); osc.connect(oscGain); oscGain.connect(envelope); osc.start(startTime); osc.stop(startTime + 1.5); });
                    osc1.start(startTime); osc1.stop(startTime + 2);
                }

                async function playNote(frequency, time) {
                    await init();
                    
                    if (!audioCtx || frequency <= 0) return;

                    const buffersForCurrentType = audioBuffers[currentSoundType];
                    
                    if (!buffersForCurrentType || buffersForCurrentType.length === 0) {
                        playNoteSynth(frequency, time);
                        return;
                    }
                    
                    const now = audioCtx.currentTime;
                    const startTime = now + time;
                    
                    const randomIndex = Math.floor(Math.random() * buffersForCurrentType.length);
                    const selectedBuffer = buffersForCurrentType[randomIndex];
                    const source = audioCtx.createBufferSource();
                    source.buffer = selectedBuffer;

                    const baseHz = SAMPLE_CONFIG[currentSoundType].baseHz;
                    const cents = 1200 * Math.log2(frequency / baseHz);
                    source.detune.value = cents;

                    const envelope = audioCtx.createGain();
                    envelope.gain.setValueAtTime(0, startTime);
                    envelope.gain.linearRampToValueAtTime(1.0, startTime + 0.02);
                    envelope.gain.exponentialRampToValueAtTime(0.0001, startTime + 2.0);

                    source.connect(envelope);
                    envelope.connect(masterGain);
                    
                    source.start(startTime);
                }

                function playSequence(frequencies, delay = 0.08) {
                    frequencies.forEach((freq, i) => { if (freq) playNote(freq, i * delay); });
                }

                function setVolume(level) {
                    if (masterGain) {
                        masterGain.gain.setTargetAtTime(level, audioCtx.currentTime, 0.01);
                    }
                }

                function setSoundType(type) {
                    if (SAMPLE_CONFIG[type]) {
                        console.log(`Sound type changed to: ${type}`);
                        currentSoundType = type;
                    } else {
                        console.warn(`Attempted to set unknown sound type: ${type}`);
                    }
                }

                return { init, playNote, playSequence, setVolume, setSoundType };
            })();

            // --- CONSTANTS ---
            const MIN_STRINGS = 1, MAX_STRINGS = 12, MIN_FRETS = 0, MAX_FRETS = 36;
            const STEEL_DENSITY_KG_M3 = 7850, LBS_TO_NEWTONS = 4.44822, INCH_TO_METER = 0.0254;
            const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const KEYBOARD_MAP = { 'a': 60, 'w': 61, 's': 62, 'e': 63, 'd': 64, 'f': 65, 't': 66, 'g': 67, 'y': 68, 'h': 69, 'u': 70, 'j': 71, 'k': 72 };
            const GUITAR_TUNING_HZ = [82.41,110.00,146.83,196.00,246.94,329.63], GUITAR_GAUGES = [0.042,0.032,0.024,0.016,0.011,0.009];
            const BASS_TUNING_HZ = [41.20,55.00,73.42,98.00], BASS_GAUGES = [0.105,0.085,0.065,0.045];
            const UKULELE_TUNING_HZ = [392.00,261.63,329.63,440.00], UKULELE_GAUGES = [0.028,0.040,0.032,0.022];
            const DROP_D_TUNING_HZ = [73.42,110.00,146.83,196.00,246.94,329.63], DROP_D_GAUGES = GUITAR_GAUGES;
            const OPEN_G_TUNING_HZ = [73.42,98.00,146.83,196.00,246.94,293.66], OPEN_G_GAUGES = [0.046,0.036,0.026,0.017,0.013,0.010];
            const DADGAD_TUNING_HZ = [73.42,110.00,146.83,196.00,220.00,293.66], DADGAD_GAUGES = [0.056,0.042,0.032,0.024,0.016,0.012];
            const SEVEN_STRING_TUNING_HZ = [61.74, ...GUITAR_TUNING_HZ], SEVEN_STRING_GAUGES = [0.059, ...GUITAR_GAUGES];
            const EIGHT_STRING_TUNING_HZ = [46.25, ...SEVEN_STRING_TUNING_HZ], EIGHT_STRING_GAUGES = [0.074, ...SEVEN_STRING_GAUGES];
            const KANTELE_5_MAJOR_HZ = [196.00, 220.00, 246.94, 261.63, 293.66], KANTELE_5_GAUGES = [0.018, 0.016, 0.014, 0.013, 0.011];
            const KANTELE_5_MINOR_HZ = [220.00, 246.94, 261.63, 293.66, 329.63], KANTELE_5_MINOR_GAUGES = KANTELE_5_GAUGES;
            const KANTELE_11_HZ = [196.00, 220.00, 246.94, 261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25], KANTELE_11_GAUGES = [0.022, 0.020, 0.018, 0.016, 0.014, 0.012, 0.011, 0.010, 0.009, 0.008, 0.007];
            const JUST_INTONATION_RATIOS = [1/1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8];
            const TRUE_TEMPERAMENT_OFFSETS_CENTS = [ [0, -2, 0, -1, 0, -2, -4, 0, -2, 0, -1, 0], [0, -2, 0, -1, 0, -2, -4, 0, -2, 0, -1, 0], [0, -2, 0, -1, 0, -2, -4, 0, -2, 0, -1, 0], [0, +12, +14, +12, +14, +12, +10, +14, +16, +14, +12, +14], [0, -2, 0, -1, 0, -2, -4, 0, -2, 0, -1, 0], [0, -2, 0, -1, 0, -2, -4, 0, -2, 0, -1, 0] ];
            const CHORD_DEFINITIONS = { 'Major': {steps:[4,3]},'Minor': {steps:[3,4]},'Diminished': {steps:[3,3]},'Augmented': {steps:[4,4]},'Dominant 7th': {steps:[4,3,3]},'Major 7th': {steps:[4,3,4]},'Minor 7th': {steps:[3,4,3]},'Major 6th': {steps:[4,3,2]},'Minor 6th': {steps:[3,4,2]}, 'Suspended 2nd': {steps:[2,5]},'Suspended 4th': {steps:[5,2]},'Major 9th': {steps:[4,3,4,3]},'Dominant 9th': {steps:[4,3,3,4]},'Minor 9th': {steps:[3,4,3,4]},'11th':{steps:[4,3,3,7]},'Dominant 13th':{steps:[4,3,3,4,7]},'Major 13th':{steps:[4,3,4,3,7]},'Minor 13th':{steps:[3,4,3,4,7]} };
            const CHORD_DEFINITIONS_19 = { 'Subminor (19)': { steps: [4, 7] }, 'Supermajor (19)': { steps: [7, 4] }, 'Diminished Seventh (19)': { steps: [5, 5, 5] } };
            const CHORD_DEFINITIONS_24 = { 'Neutral (24)': { steps: [7, 7] } };
            const CHORD_DEFINITIONS_31 = { 'Neutral (31)': { steps: [9, 9] }, 'Barbershop Seventh (31)': { steps: [10, 8, 7] }, 'I Supermajor Minor Seven (31)': { steps: [11, 7, 7] }, 'Septimal 11th (31)': { steps: [10, 5, 3, 7] }, 'Undecimal 11th (31)': { steps: [10, 4, 4, 7] }, 'Neutral Harmonic Seventh (31)': { steps: [9, 9, 7] }, 'Neutral Minor Seventh (31)': { steps: [9, 9, 8] }, 'Neutral Major Seventh (31)': { steps: [9, 9, 10] } };
            
            // All scale definitions now use relative steps
            const SCALE_DEFINITIONS = {'Major (Ionian)':[2,2,1,2,2,2,1], 'Dorian':[2,1,2,2,2,1,2], 'Phrygian':[1,2,2,2,1,2,2], 'Lydian':[2,2,2,1,2,2,1], 'Mixolydian':[2,2,1,2,2,1,2], 'Minor (Aeolian)':[2,1,2,2,1,2,2], 'Locrian':[1,2,2,1,2,2,2], 'Harmonic Minor':[2,1,2,2,1,3,1], 'Locrian #6': [1,2,2,1,3,1,2], 'Phrygian Dominant':[1,3,1,2,1,2,2], 'Melodic Minor':[2,1,2,2,2,2,1], 'Major Pentatonic':[2,2,3,2,3], 'Minor Pentatonic':[3,2,2,3,2], 'Blues':[3,2,1,1,3,2], 'Neapolitan Minor': [1,2,2,2,1,3,1], 'Byzantine': [1,3,1,2,1,3,1]};
            const SCALE_DEFINITIONS_19 = { 'Supermajor Lydian (19)': [3,4,1,3,3,3,2], 'Subminor Pentatonic (19)': [4,2,5,4,4] };
            const SCALE_DEFINITIONS_24 = { 'Neutral Ionian (24)': [4,3,3,4,4,3,3], 'Neutral Dorian (24)': [3,3,4,4,3,3,4], 'Neutral Phrygian (24)': [3,4,4,3,3,4,3], 'Neutral Lydian (24)': [4,4,3,3,4,3,3], 'Neutral Mixolydian (24)': [4,3,3,4,3,3,4], 'Neutral Aeolian (24)': [3,3,4,3,3,4,4], 'Neutral Locrian (24)': [3,4,3,3,4,4,3], 'Neutral Whole (24)': [3,4,3,4,3,4,3], 'Maqam Bayati (24)': [3,2,4,4,2,4,4], 'Maqam Rast Asc (24)': [4,3,2,4,4,3,4], 'Maqam Rast Desc (24)': [4,3,2,4,4,4,3], 'Maqam Saba (24)': [3,2,2,6,2,4,4], 'Maqam Sigah (24)': [2,4,4,3,2,4,5], 'Maqam Ajam (24)': [4,4,2,4,4,4,2], 'Maqam Hoseyni (24)': [3,2,4,3,2,4,6], 'Maqam Nahawand (24)': [4,2,4,4,2,4,4], 'Maqam Hijaz (24)': [2,6,2,4,2,4,4], 'Maqam Kurd (24)': [2,4,4,2,4,4,4] };
            const SCALE_DEFINITIONS_31 = { 'Neutral (31)': [4,4,3,4,4,4,4], 'Gamelan Pelog (31)': [3,4,7,3,4,7,3], 'Gamelan pseudo-Slendro (31)': [6,6,6,6,7], 'Pure Blues (31)': [10,8,7,6], 'Undecimal Blues (31)': [10,4,4,9,4], 'Mothra (Square Wave) (31)': [5,5,4,4,4,3,3,3], 'Supermajor Hexatonic (31)': [5,6,2,5,7,6] };

            const INTERVAL_NAMES = {0:'R',1:'b2',2:'2',3:'b3',4:'3',5:'4',6:'b5',7:'5',8:'#5',9:'6',10:'b7',11:'7',12:'R',13:'b9',14:'9',15:'#9',16:'b11',17:'11',18:'#11',19:'b13',20:'6',21:'13'};
            const ROMAN_INTERVAL_NAMES = {0:'I',1:'bII',2:'II',3:'bIII',4:'III',5:'IV',6:'bV',7:'V',8:'#V',9:'VI',10:'bVII',11:'VII'};
            const DIATONIC_DEGREES = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
            const DIATONIC_MODE_NAMES = ['Ionian', 'Dorian', 'Phrygian', 'Lydian', 'Mixolydian', 'Aeolian', 'Locrian'];
            const MAJOR_SCALE_DIATONIC_CHORDS = [ {type: 'Major', roman: 'I'}, {type: 'Minor', roman: 'ii'}, {type: 'Minor', roman: 'iii'}, {type: 'Major', roman: 'IV'}, {type: 'Major', roman: 'V'}, {type: 'Minor', roman: 'vi'}, {type: 'Diminished', roman: 'vii¬∞'} ];
            const MINOR_SCALE_DIATONIC_CHORDS = [ {type: 'Minor', roman: 'i'}, {type: 'Diminished', roman: 'ii¬∞'}, {type: 'Major', roman: 'bIII'}, {type: 'Minor', roman: 'iv'}, {type: 'Minor', roman: 'v'}, {type: 'Major', roman: 'bVI'}, {type: 'Major', roman: 'bVII'} ];
            const EDO_SYSTEMS = {
                19: {
                    names: ["C", "C‚ôØ", "D‚ô≠", "D", "D‚ôØ", "E‚ô≠", "F‚ô≠", "E", "F", "F‚ôØ", "G‚ô≠", "G", "G‚ôØ", "A‚ô≠", "A", "A‚ôØ", "B‚ô≠", "C‚ô≠", "B"],
                    intervals: ["R", "A1", "m2", "N2", "M2", "A2", "d3", "m3", "M3", "d4", "P4", "A4", "d5", "P5", "m6", "M6", "m7", "d8", "M7"]
                },
                24: {
                    names: ["C", "Cq‚ôØ", "C‚ôØ", "Dq‚ô≠", "D", "Dq‚ôØ", "D‚ôØ", "Eq‚ô≠", "E", "Fq‚ô≠", "F", "Fq‚ôØ", "F‚ôØ", "Gq‚ô≠", "G", "Gq‚ôØ", "G‚ôØ", "Aq‚ô≠", "A", "Aq‚ôØ", "A‚ôØ", "Bq‚ô≠", "B", "Cq‚ô≠"],
                    intervals: ["R", "qA1", "m2", "qN2", "M2", "qA2", "d3", "qm3", "m3", "qM3", "M3", "qd4", "P4", "qA4", "A4", "qd5", "d5", "qP5", "P5", "qA5", "A5", "qm7", "m7", "qM7"]
                },
                31: {
                    names: ["C", "C‚Üë", "C‚ôØ", "D‚ô≠", "D‚Üì", "D", "D‚Üë", "D‚ôØ", "E‚ô≠", "E‚Üì", "F‚ô≠", "E", "E‚Üë", "F", "F‚Üë", "F‚ôØ", "G‚ô≠", "G‚Üì", "G", "G‚Üë", "G‚ôØ", "A‚ô≠", "A‚Üì", "A", "A‚Üë", "A‚ôØ", "B‚ô≠", "B‚Üì", "C‚ô≠", "B", "B‚Üë"],
                    intervals: ["R", "‚Üë1", "m2", "M2-", "‚Üì2", "M2", "‚Üë2", "m3", "M3-", "‚Üì3", "d4", "M3", "‚Üë3", "P4", "‚Üë4", "A4", "d5", "‚Üì5", "P5", "‚Üë5", "m6", "M6-", "‚Üì6", "M6", "‚Üë6", "m7", "M7-", "‚Üì7", "d8", "M7", "‚Üë7"]
                }
            };
            
            const ZEITLER_SCALE_DEFINITIONS = {};
            let ALL_SCALE_DEFINITIONS_FOR_RECOGNITION = {};

            // --- STATE ---
            let state = { 
                strings: [], frets: 12, notes: [], fretPositions: [], currentChord: null, currentScale: null, tuningPanelVisible: true, noteDisplayMode: 'names', notesPerStringLimit: 'all', showFretNumbers: true, isRootLocked: false, isPlayerView: true, isLeftHanded: false, interactionMode: 'toggle_note', midiAccess: null, midiInputs: [], midiOutputs: [], selectedMidiInId: null, selectedMidiOutId: null, activeMidiNotes: new Map(),
                masterVolume: 0.8,
                temperament: 12,
                currentChordDefs: {},
                currentScaleDefs: {},
                scaleStepsToNameMap: new Map(),
                isZeitlerMode: false,
                instrumentMode: null, overtoneFundamentalHz: null 
            };

            // --- DOM ELEMENTS ---
            const mainLayout = document.getElementById('main-layout'), stringControlsContainer = document.getElementById('string-controls-container'), fretboardWrapper = document.getElementById('fretboard-wrapper'), fretboardContainer = document.getElementById('fretboard-container'), fretNumbersContainer = document.getElementById('fret-numbers-container');
            const zoomSlider = document.getElementById('zoom-slider');
            const masterVolumeSlider = document.getElementById('master-volume-slider');
            const overtoneComments = document.getElementById('overtone-comments');
            const zeitlerCredit = document.getElementById('zeitler-credit');
            const fretCountEl = document.getElementById('fret-count');
            const addLowStringBtn = document.getElementById('add-low-string'), addHighStringBtn = document.getElementById('add-high-string');
            const addFretBtn = document.getElementById('add-fret'), removeFretBtn = document.getElementById('remove-fret');
            const rootNoteSelect = document.getElementById('root-note-select'), chordTypeSelect = document.getElementById('chord-type-select'), showChordBtn = document.getElementById('show-chord-btn'), clearFretboardBtn = document.getElementById('clear-fretboard-btn');
            const playStrumBtn = document.getElementById('play-strum-btn'), playShredBtn = document.getElementById('play-shred-btn');
            const recognizedChordDisplay = document.getElementById('recognized-chord-display'), recognizedScaleDisplay = document.getElementById('recognized-scale-display');
            const currentRootDisplay = document.getElementById('current-root-display'), currentNotesDisplay = document.getElementById('current-notes-display');
            const scaleTypeSelect = document.getElementById('scale-type-select'), showScaleBtn = document.getElementById('show-scale-btn'), randomScaleBtn = document.getElementById('random-scale-btn'), notesPerStringSelect = document.getElementById('notes-per-string-select');
            const scaleSearchInput = document.getElementById('scale-search-input');
            const resetFretsBtn = document.getElementById('reset-frets'), toggleTuningBtn = document.getElementById('toggle-tuning-panel'), displayModeSelect = document.getElementById('display-mode'), setupSelect = document.getElementById('setup-select');
            const showFretNumbersBtn = document.getElementById('show-fret-numbers-btn'), showAllNotesBtn = document.getElementById('show-all-notes-btn'), reverseStringsBtn = document.getElementById('reverse-strings-btn'), leftHandedBtn = document.getElementById('left-handed-btn'), editPlayModeSelect = document.getElementById('edit-play-mode');
            const soundTypeSelect = document.getElementById('sound-type-select');
            const toggleScaleSetBtn = document.getElementById('toggle-scale-set-btn');
            const midiInSelect = document.getElementById('midi-in-select'), midiOutSelect = document.getElementById('midi-out-select');
            const cofSvg = document.getElementById('cof-svg'), cofLockBtn = document.getElementById('cof-lock-btn'), cofLockIcon = document.getElementById('cof-lock-icon');
            const scaleModesContainer = document.getElementById('scale-modes-container'), scaleModesList = document.getElementById('scale-modes-list');
            // Tab DOM elements
            const tabGrid = document.getElementById('tab-grid'), tabPlayhead = document.getElementById('tab-playhead'), tempoInput = document.getElementById('tempo-input'), textTabIo = document.getElementById('text-tab-io'), midiFileInput = document.getElementById('midi-file-input');
            const playTabBtn = document.getElementById('play-tab-btn'), stopTabBtn = document.getElementById('stop-tab-btn'), addTabColBtn = document.getElementById('add-tab-col-btn'), removeTabColBtn = document.getElementById('remove-tab-col-btn');
            const importTextTabBtn = document.getElementById('import-text-tab-btn'), exportTextTabBtn = document.getElementById('export-text-tab-btn'), exportMidiBtn = document.getElementById('export-midi-btn');

            // --- HELPER, PHYSICS & CHORD/SCALE FUNCTIONS ---
            function stepsToIntervals(steps) { const intervals = [0]; let currentSemitone = 0; for (let i = 0; i < steps.length - 1; i++) { currentSemitone += parseInt(steps[i], 10); intervals.push(currentSemitone); } return intervals; }
            function chordStepsToAbsoluteIntervals(steps) { if (!steps) return [0]; const intervals = [0]; let currentSemitone = 0; for (const step of steps) { currentSemitone += parseInt(step, 10); intervals.push(currentSemitone); } return intervals; }
            function getVisualThickness(gauge) { const minGauge = 0.007, maxGauge = 0.110, minPx = 1.0, maxPx = 7.0; const clampedGauge = Math.max(minGauge, Math.min(gauge, maxGauge)); const gaugeRange = maxGauge - minGauge, pxRange = maxPx - minPx; return minPx + ((clampedGauge - minGauge) / gaugeRange) * pxRange; }
            function calculateFrequency(string) { if (!string || string.length <= 0 || string.width <= 0 || string.tension <= 0) return 0; const length_m = string.length * INCH_TO_METER, width_m = string.width * INCH_TO_METER, tension_N = string.tension * LBS_TO_NEWTONS; const radius_m = width_m / 2, area_m2 = Math.PI * Math.pow(radius_m, 2), linearDensity_mu = STEEL_DENSITY_KG_M3 * area_m2; return (1 / (2 * length_m)) * Math.sqrt(tension_N / linearDensity_mu); }
            function calculateLength(tension, width, frequency) { if(frequency <= 0) return 0; const width_m = width * INCH_TO_METER; const radius_m = width_m / 2; const area_m2 = Math.PI * Math.pow(radius_m, 2); const linearDensity_mu = STEEL_DENSITY_KG_M3 * area_m2; const tension_N = tension * LBS_TO_NEWTONS; const length_m = (1 / (2 * frequency)) * Math.sqrt(tension_N / linearDensity_mu); return length_m / INCH_TO_METER; }
            function calculateTension(string, targetFrequency) { if (!string || string.length <= 0 || string.width <= 0 || targetFrequency <= 0) return 0; const length_m = string.length * INCH_TO_METER, width_m = string.width * INCH_TO_METER; const radius_m = width_m / 2, area_m2 = Math.PI * Math.pow(radius_m, 2), linearDensity_mu = STEEL_DENSITY_KG_M3 * area_m2; const tension_N = linearDensity_mu * Math.pow(targetFrequency * 2 * length_m, 2); return tension_N / LBS_TO_NEWTONS; }
            function calculateFrettedFrequency(stringIndex, fretIndex) { if(fretIndex >= state.frets) return 0; const string = state.strings[stringIndex]; if (fretIndex === -1) return calculateFrequency(string); const fretDividerPosition = state.fretPositions[stringIndex][fretIndex + 1]; const lengthRatio = (100 - fretDividerPosition) / 100; const frettedLength = string.length * lengthRatio; return calculateFrequency({ ...string, length: frettedLength }); }
            function createStringWithTuning(freq, gauge) { const tempString = { length: 24.0, width: gauge }; return { ...tempString, tension: calculateTension(tempString, freq) }; }
            function midiToFrequency(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }
            function frequencyToMidi(frequency) { return Math.round(69 + 12 * Math.log2(frequency / 440.0)); }
            function frequencyToEdoInfo(frequency) {
                if (!frequency || frequency <= 0) return null;

                const edo = state.temperament || 12;
                
                if (edo === 12) {
                    const midi = frequencyToMidi(frequency);
                    return {
                        midi: midi,
                        absoluteStep: midi,
                        octave: Math.floor(midi / 12) - 1,
                        stepInOctave: midi % 12,
                        noteName: NOTE_NAMES[midi % 12]
                    };
                }
                const C0_HZ = 16.351597831287414;
                const absoluteStep = Math.round(edo * Math.log2(frequency / C0_HZ));
                const octave = Math.floor(absoluteStep / edo);
                const stepInOctave = absoluteStep % edo;
                const edoData = EDO_SYSTEMS[edo] || {};
                const noteName = (edoData.names && edoData.names[stepInOctave]) ? edoData.names[stepInOctave] : `S:${stepInOctave}`;
                return { absoluteStep, octave, stepInOctave, noteName };
            }
            function frequencyToNoteName(frequency) { if (frequency <= 0) return "N/A"; const midiNoteNumber = frequencyToMidi(frequency); return `${NOTE_NAMES[midiNoteNumber % 12]}`; }
            function generateInitialFretPositions(temperament = 12) {
                state.fretPositions = [];
                for (let i = 0; i < state.strings.length; i++) {
                    const stringFrets = [0];
                    if (temperament === 'just') {
                        for (let j = 0; j < state.frets; j++) {
                            const ratio = JUST_INTONATION_RATIOS[j % 12] * Math.pow(2, Math.floor(j / 12));
                            stringFrets.push((1 - (1 / ratio)) * 100);
                        }
                    } else if (temperament === 'true_temperament' && i < TRUE_TEMPERAMENT_OFFSETS_CENTS.length) {
                        const twelfthRootOfTwo = Math.pow(2, 1/12);
                        for (let j = 0; j < state.frets; j++) {
                            const et_ratio = Math.pow(twelfthRootOfTwo, j + 1);
                            const cents_offset = (TRUE_TEMPERAMENT_OFFSETS_CENTS[i][j % 12] || 0);
                            const final_ratio = et_ratio * Math.pow(2, cents_offset / 1200);
                            stringFrets.push((1 - (1 / final_ratio)) * 100);
                        }
                    } else if (typeof temperament === 'number') { // Handles all EDOs (12, 19, 24, 31, etc.)
                        const stepRatio = Math.pow(2, 1 / temperament);
                        let remainingLength = 100;
                        for (let j = 0; j < state.frets; j++) {
                            stringFrets.push(100 - (remainingLength / stepRatio));
                            remainingLength /= stepRatio;
                        }
                    }
                    stringFrets.push(100);
                    state.fretPositions.push(stringFrets);
                }
            }
            function findChordVoicing(rootNoteIndex, chordType) {
                const rootNoteName = NOTE_NAMES[rootNoteIndex];
                if (state.strings.length === 6 && VOICING_LIBRARY[rootNoteName] && VOICING_LIBRARY[rootNoteName][chordType]) {
                    const pattern = VOICING_LIBRARY[rootNoteName][chordType];
                    return pattern.map((voiceData, stringIndex) => ({ string: stringIndex, fret: voiceData.fret, finger: voiceData.finger }));
                }
                const chordSteps = (state.currentChordDefs[chordType] || {steps:[]}).steps;
                const chordIntervals = chordStepsToAbsoluteIntervals(chordSteps);
                const chordNoteIndexes = chordIntervals.map(i => (rootNoteIndex + i) % 12);
                let voicing = [];
                for (let i = 0; i < state.strings.length; i++) {
                    const openStringMidi = frequencyToMidi(calculateFrequency(state.strings[i]));
                    let bestFret = null;
                    for (let fret = -1; fret < state.frets; fret++) {
                        const currentNoteMidi = openStringMidi + (fret + 1);
                        const currentNoteIndex = currentNoteMidi % 12;
                        if (chordNoteIndexes.includes(currentNoteIndex)) {
                            bestFret = fret;
                            break;
                        }
                    }
                    voicing.push({ string: i, fret: bestFret });
                }
                return voicing;
            }
            function recognizeChord(notes) { if (notes.length < 3) return null; const pitchClasses = [...new Set(notes.map(n => frequencyToMidi(calculateFrettedFrequency(n.string, n.fret)) % 12))].sort((a, b) => a - b); if (pitchClasses.length < 2) return null; for (const potentialRoot of pitchClasses) { const intervals = pitchClasses.map(pc => (pc - potentialRoot + 12) % 12).sort((a,b) => a - b); for (const chordName in CHORD_DEFINITIONS) { const defSteps = CHORD_DEFINITIONS[chordName].steps; const defIntervals = chordStepsToAbsoluteIntervals(defSteps); if (intervals.length === defIntervals.length && intervals.every((val, index) => val === defIntervals[index])) { return { root: NOTE_NAMES[potentialRoot], type: chordName, rootIndex: potentialRoot }; } } } return null; }
            function recognizeScale(notes) { const pitchClasses = [...new Set(notes.map(n => frequencyToMidi(calculateFrettedFrequency(n.string, n.fret)) % 12))].sort((a, b) => a - b); if (pitchClasses.length < 5) return null; for (const potentialRoot of pitchClasses) { const intervals = pitchClasses.map(pc => (pc - potentialRoot + 12) % 12).sort((a,b) => a - b); for (const scaleName in ALL_SCALE_DEFINITIONS_FOR_RECOGNITION) { const defIntervals = ALL_SCALE_DEFINITIONS_FOR_RECOGNITION[scaleName]; if (intervals.length === defIntervals.length && intervals.every((val, index) => val === defIntervals[index])) { return { root: NOTE_NAMES[potentialRoot], type: scaleName, rootIndex: potentialRoot }; } } } return null; }

            // --- RENDER & UI FUNCTIONS ---
            function renderApp() {
                if (state.tuningPanelVisible) { stringControlsContainer.style.display = 'flex'; mainLayout.style.gridTemplateColumns = '460px 1fr'; } else { stringControlsContainer.style.display = 'none'; mainLayout.style.gridTemplateColumns = '1fr'; }
                toggleTuningBtn.textContent = state.tuningPanelVisible ? 'Hide Tuning' : 'Show Tuning';
                if (state.isLeftHanded) fretboardWrapper.classList.add('left-handed'); else fretboardWrapper.classList.remove('left-handed');
                
                overtoneComments.style.display = (state.instrumentMode === 'overtone') ? 'block' : 'none';

                const isManualMode = !state.currentChord && !state.currentScale;
                const recognizedChord = (isManualMode && state.temperament === 12) ? recognizeChord(state.notes) : null;
                const recognizedScale = (isManualMode && !recognizedChord && state.temperament === 12) ? recognizeScale(state.notes) : null;

                recognizedChordDisplay.textContent = '';
                recognizedChordDisplay.classList.remove('clickable');
                recognizedChordDisplay.removeAttribute('data-root-index');
                recognizedChordDisplay.removeAttribute('data-type');
                
                if (state.temperament !== 12) {
                    recognizedChordDisplay.textContent = 'Recognition disabled for non-12-EDO tunings.';
                    recognizedScaleDisplay.textContent = '';
                } else if (recognizedChord) {
                    recognizedChordDisplay.textContent = `Recognized: ${recognizedChord.root} ${recognizedChord.type}`;
                    recognizedChordDisplay.classList.add('clickable');
                    recognizedChordDisplay.dataset.rootIndex = recognizedChord.rootIndex;
                    recognizedChordDisplay.dataset.type = recognizedChord.type;
                }
                
                recognizedScaleDisplay.textContent = '';
                recognizedScaleDisplay.classList.remove('clickable');
                recognizedScaleDisplay.removeAttribute('data-root-index');
                recognizedScaleDisplay.removeAttribute('data-type');

                if (recognizedScale) {
                    recognizedScaleDisplay.textContent = `Recognized: ${recognizedScale.root} ${recognizedScale.type}`;
                    recognizedScaleDisplay.classList.add('clickable');
                    recognizedScaleDisplay.dataset.rootIndex = recognizedScale.rootIndex;
                    recognizedScaleDisplay.dataset.type = recognizedScale.type;
                }
                
                cofSvg.parentElement.style.display = state.temperament === 12 ? 'flex' : 'none';
                scaleModesContainer.style.display = state.currentScale ? 'flex' : 'none';

                stringControlsContainer.innerHTML = ''; fretboardContainer.innerHTML = ''; fretNumbersContainer.innerHTML = '';
                
                // Determine render order based on Player vs Spectator view
                const stringIndices = Array.from({ length: state.strings.length }, (_, k) => k);
                const renderOrder = state.isPlayerView ? [...stringIndices].reverse() : stringIndices;

                // Render controls and strings in the determined order
                renderOrder.forEach(i => {
                    if(state.tuningPanelVisible) renderStringControlPanel(state.strings[i], i);
                });
                if(state.showFretNumbers && state.frets > 0) renderFretNumbers();
                renderOrder.forEach(i => renderStringRow(state.strings[i], i));
                
                TabEditor.render();
                updateGlobalControls(); 
                updateFretboardModeClass();
                attachEventListeners();
            }
            function renderStringControlPanel(string, index) {
                const panel = document.createElement('div'); panel.className = 'string-control-panel';
                if (state.instrumentMode === 'overtone' && state.strings.length > 0) {
                    const fundamentalLength = state.strings[0].length;
                    panel.style.width = `${(string.length / fundamentalLength) * 100}%`;
                }
                const freq = calculateFrequency(string); 
                const edoInfo = frequencyToEdoInfo(freq);
                const noteName = `${edoInfo.noteName}${edoInfo.octave}`;
                panel.innerHTML = `<div class="input-group"><label for="len-${index}">Len:</label><input type="number" id="len-${index}" value="${string.length.toFixed(1)}" step="0.1" min="1" max="50"></div><div class="input-group"><label for="wid-${index}">Gauge:</label><input type="number" id="wid-${index}" value="${string.width.toFixed(3)}" step="0.001" min="0.007" max="0.080"></div><div class="input-group"><label for="ten-${index}">Ten (lbs):</label><input type="number" id="ten-${index}" value="${string.tension.toFixed(1)}" step="0.5" min="5" max="50"></div><div class="info-display"><span>${freq.toFixed(1)} Hz</span><span>${noteName}</span></div><button class="remove-string-btn" data-string-index="${index}" title="Remove this string">X</button>`; stringControlsContainer.appendChild(panel); const resetMode = () => { state.instrumentMode = null; updateGlobalControls(); }; panel.querySelector(`#len-${index}`).addEventListener('input', e => { clearTheory(); state.strings[index].length = parseFloat(e.target.value) || 0; resetMode(); renderApp(); }); panel.querySelector(`#wid-${index}`).addEventListener('input', e => { clearTheory(); state.strings[index].width = parseFloat(e.target.value) || 0; resetMode(); renderApp(); }); panel.querySelector(`#ten-${index}`).addEventListener('input', e => { clearTheory(); state.strings[index].tension = parseFloat(e.target.value) || 0; resetMode(); renderApp(); }); }
            function renderFretNumbers() { const openSpace = document.createElement('div'); openSpace.className = 'open-string-space'; fretNumbersContainer.appendChild(openSpace); const frettedArea = document.createElement('div'); frettedArea.className = 'fretted-area'; const refFretPositions = state.fretPositions[0] || []; for (let j = 0; j < state.frets; j++) { const numEl = document.createElement('div'); numEl.className = 'fret-number'; numEl.textContent = j + 1; numEl.style.width = `${(refFretPositions[j+1] || 100) - (refFretPositions[j] || 0)}%`; frettedArea.appendChild(numEl); } fretNumbersContainer.appendChild(frettedArea); }
            function renderStringRow(string, i) {
                const stringRow = document.createElement('div'); stringRow.className = 'string-row'; stringRow.dataset.stringIndex = i;
                if (state.instrumentMode === 'overtone' && state.strings.length > 0) {
                    const fundamentalLength = state.strings[0].length;
                    stringRow.style.width = `${(string.length / fundamentalLength) * 100}%`;
                }
                const thickness = getVisualThickness(string.width); stringRow.style.setProperty('--string-thickness', `${thickness.toFixed(2)}px`); const openSpace = document.createElement('div'); openSpace.className = 'fret-space open-string-space'; openSpace.dataset.stringIndex = i; openSpace.dataset.fretIndex = -1; stringRow.appendChild(openSpace); const frettedArea = document.createElement('div'); frettedArea.className = 'fretted-area';
                if (state.fretPositions[i]) { for (let j = 0; j < state.frets; j++) { const fretSpace = document.createElement('div'); fretSpace.className = 'fret-space'; fretSpace.style.width = `${state.fretPositions[i][j + 1] - state.fretPositions[i][j]}%`; fretSpace.dataset.stringIndex = i; fretSpace.dataset.fretIndex = j; frettedArea.appendChild(fretSpace); if (j < state.frets) { const fretDivider = document.createElement('div'); fretDivider.className = 'fret-divider'; fretDivider.style.left = `${state.fretPositions[i][j + 1]}%`; fretDivider.dataset.stringIndex = i; fretDivider.dataset.fretIndex = j + 1; frettedArea.appendChild(fretDivider); } } }
                stringRow.appendChild(frettedArea);
                state.notes.filter(n => n.string === i && n.fret !== null).forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'note';
                    noteEl.dataset.string = note.string;
                    noteEl.dataset.fretIndex = note.fret;
                    
                    const frettedFreq = calculateFrettedFrequency(note.string, note.fret);
                    const edoInfo = frequencyToEdoInfo(frettedFreq);
                    let label = '';

                    switch(state.noteDisplayMode) {
                        case 'names':
                            label = `${edoInfo.noteName}${edoInfo.octave}`;
                            break;
                        case 'frequencies':
                            label = `${frettedFreq.toFixed(0)}Hz`;
                            break;
                        case 'intervals':
                        case 'intervals_roman':
                            if (state.temperament === 12) {
                                const rootNoteIndex = parseInt(rootNoteSelect.value);
                                const rootMidi = 48 + rootNoteIndex;
                                const intervalSemitones = edoInfo.midi - rootMidi;
                                
                                if (state.noteDisplayMode === 'intervals_roman') {
                                    const normalizedInterval = (intervalSemitones % 12 + 12) % 12;
                                    label = ROMAN_INTERVAL_NAMES[normalizedInterval] || '?';
                                } else {
                                    label = note.interval || INTERVAL_NAMES[intervalSemitones] || INTERVAL_NAMES[(intervalSemitones % 12 + 12) % 12] || '?';
                                }
                            } else {
                                const rootNoteIndex12 = parseInt(rootNoteSelect.value);
                                const rootFreq = midiToFrequency(48 + rootNoteIndex12);
                                const rootEdoInfo = frequencyToEdoInfo(rootFreq);
                                const intervalSteps = edoInfo.absoluteStep - rootEdoInfo.absoluteStep;
                                const edoData = EDO_SYSTEMS[state.temperament] || {};
                                label = (edoData.intervals && edoData.intervals[(intervalSteps % state.temperament + state.temperament) % state.temperament]) ? edoData.intervals[(intervalSteps % state.temperament + state.temperament) % state.temperament] : `${intervalSteps}`;
                            }
                            break;
                        case 'fingerings': noteEl.textContent = note.finger ? note.finger : (note.fret === -1 ? 'O' : (note.fret + 1)); break;
                        case 'cents': let rootInOctaveMidi = Math.floor(frequencyToMidi(frettedFreq) / 12) * 12 + parseInt(rootNoteSelect.value); if (rootInOctaveMidi > frequencyToMidi(frettedFreq)) rootInOctaveMidi -= 12; const rootInOctaveFreq = 440 * Math.pow(2, (rootInOctaveMidi - 69) / 12); const cents = 1200 * Math.log2(frettedFreq / rootInOctaveFreq); noteEl.textContent = `${cents.toFixed(0)}¬¢`; break;
                    }
                    if (label) {
                        noteEl.textContent = label;
                    }

                    if (note.fret === -1) { noteEl.style.left = '50%'; openSpace.appendChild(noteEl); } 
                    else { const fretStart = state.fretPositions[note.string][note.fret], fretEnd = state.fretPositions[note.string][note.fret + 1]; noteEl.style.left = `${fretStart + (fretEnd - fretStart) / 2}%`; frettedArea.appendChild(noteEl); }
                });
                fretboardContainer.appendChild(stringRow);
            }
            
            // --- EVENT LISTENERS & HANDLERS ---
            function attachEventListeners() { 
                document.body.addEventListener('click', handleDelegatedClick); 
                fretboardContainer.addEventListener('mousedown', handleFretDragStart); 
            }
            function handleDelegatedClick(e) {
                const noteEl = e.target.closest('.note');
                const fretSpace = e.target.closest('.fret-space');
                const targetElement = noteEl || fretSpace;

                if (targetElement) {
                    const stringIndex = parseInt(targetElement.dataset.stringIndex ?? noteEl?.dataset.string);
                    const fretIndex = parseInt(targetElement.dataset.fretIndex ?? noteEl?.dataset.fretIndex);
                    const noteExists = state.notes.some(n => n.string === stringIndex && n.fret === fretIndex);

                    // If a pre-defined chord or scale is active, interacting with the board
                    // should switch to manual edit mode. We do this by nullifying the
                    // current chord/scale state, which allows the recognition logic
                    // to take over on the next render. The notes themselves are preserved.
                    if (state.currentChord || state.currentScale) {
                        state.currentChord = null;
                        state.currentScale = null;
                        currentRootDisplay.textContent = '';
                        currentNotesDisplay.textContent = '';
                        updateCircleOfFifths(null);
                        updateScaleModesDisplay();
                    }

                    switch (state.interactionMode) {
                        case 'toggle_note':
                            if (noteExists) { removeNote(stringIndex, fretIndex); } else { addNote(stringIndex, fretIndex); }
                            break;
                        case 'insert':
                            if (!noteExists) { addNote(stringIndex, fretIndex); }
                            break;
                        case 'remove':
                            if (noteExists) { removeNote(stringIndex, fretIndex); }
                            break;
                        case 'play':
                            AudioPlayer.playNote(calculateFrettedFrequency(stringIndex, fretIndex), 0);
                            break;
                    }
                    return;
                }
                
                const removeBtn = e.target.closest('.remove-string-btn'); 
                if (removeBtn) { removeString(parseInt(removeBtn.dataset.stringIndex)); return; }
                const recognizedChordEl = e.target.closest('#recognized-chord-display');
                if (recognizedChordEl && recognizedChordEl.dataset.type) {
                    rootNoteSelect.value = recognizedChordEl.dataset.rootIndex;
                    chordTypeSelect.value = recognizedChordEl.dataset.type;
                    handleShowChord();
                    return;
                }
                const recognizedScaleEl = e.target.closest('#recognized-scale-display');
                if (recognizedScaleEl && recognizedScaleEl.dataset.type) {
                    rootNoteSelect.value = recognizedScaleEl.dataset.rootIndex;
                    scaleTypeSelect.value = recognizedScaleEl.dataset.type;
                    handleShowScale();
                    return;
                }
            }
            let dragInfo = null;
            function handleFretDragStart(e) { 
                if (state.interactionMode !== 'move_fret' || !e.target.classList.contains('fret-divider')) return; 
                const stringIndex = parseInt(e.target.dataset.stringIndex), fretIndex = parseInt(e.target.dataset.fretIndex); 
                if (fretIndex === 0 || fretIndex > state.frets) return; 
                dragInfo = { element: e.target, stringIndex, fretIndex, startX: e.clientX, fretboardWidth: e.target.parentElement.clientWidth }; 
                document.addEventListener('mousemove', handleFretDrag); 
                document.addEventListener('mouseup', handleFretDragEnd); 
            }
            function handleFretDrag(e) { if(!dragInfo) return; e.preventDefault(); const dx = e.clientX - dragInfo.startX, dPercent = (dx / dragInfo.fretboardWidth) * 100, originalPos = state.fretPositions[dragInfo.stringIndex][dragInfo.fretIndex]; let newPos = originalPos + dPercent; const leftBoundary = state.fretPositions[dragInfo.stringIndex][dragInfo.fretIndex - 1] + 1, rightBoundary = state.fretPositions[dragInfo.stringIndex][dragInfo.fretIndex + 1] - 1; newPos = Math.max(leftBoundary, Math.min(newPos, rightBoundary)); dragInfo.element.style.left = `${newPos}%`; }
            function handleFretDragEnd(e) { if (!dragInfo) return; const finalPercent = parseFloat(dragInfo.element.style.left); state.fretPositions[dragInfo.stringIndex][dragInfo.fretIndex] = finalPercent; dragInfo = null; document.removeEventListener('mousemove', handleFretDrag); document.removeEventListener('mouseup', handleFretDragEnd); renderApp(); }
            
            function convertIntervalsToEdo(intervals12, targetEdo) {
                if (targetEdo === 12) return intervals12;
                const ratio = targetEdo / 12.0;
                return intervals12.map(i => Math.round(i * ratio));
            }
            function findEdoVoicing(rootNoteIndex12, edoIntervals) {
                const rootFreq = midiToFrequency(48 + rootNoteIndex12);
                const rootEdoInfo = frequencyToEdoInfo(rootFreq);
                const rootAbsoluteStep = rootEdoInfo.absoluteStep;
                const chordAbsoluteSteps = edoIntervals.map(i => rootAbsoluteStep + i);
                
                let voicing = [];
                for (let i = 0; i < state.strings.length; i++) {
                    let bestFret = null;
                    for (let j = -1; j < state.frets; j++) {
                        const noteEdoInfo = frequencyToEdoInfo(calculateFrettedFrequency(i, j));
                        if (noteEdoInfo && chordAbsoluteSteps.includes(noteEdoInfo.absoluteStep)) {
                            bestFret = j;
                            break;
                        }
                    }
                    voicing.push({ string: i, fret: bestFret });
                }
                return voicing;
            }
            function handleShowChord() {
                const rootNoteIndex = parseInt(rootNoteSelect.value);
                const chordType = chordTypeSelect.value;
                const chordDef = state.currentChordDefs[chordType];
                if (!chordDef) return;

                const baseIntervals = chordStepsToAbsoluteIntervals(chordDef.steps);
                
                let voicing;
                if (state.temperament === 12) {
                    voicing = findChordVoicing(rootNoteIndex, chordType);
                } else {
                    const edoIntervals = convertIntervalsToEdo(baseIntervals, state.temperament);
                    voicing = findEdoVoicing(rootNoteIndex, edoIntervals);
                }
                
                clearTheory(false);
                state.currentChord = { root: rootNoteIndex, type: chordType, notes: voicing };
                state.notes = voicing;
                
                const rootNoteName = NOTE_NAMES[rootNoteIndex];
                const noteNames = baseIntervals.map(i => NOTE_NAMES[(rootNoteIndex + i) % 12]).join(' ¬∑ ');
                currentRootDisplay.textContent = `Root: ${rootNoteName}`;
                currentNotesDisplay.textContent = `${chordType} (${state.temperament}-EDO): ${noteNames}`;

                updateCircleOfFifths(rootNoteIndex, 'Major (Ionian)');
                updateScaleModesDisplay();
                renderApp();
            }
            function showScaleOnFretboard(rootNoteIndex12, edoIntervals, scaleType) {
                clearTheory(false);
                state.currentScale = { root: rootNoteIndex12, type: scaleType, intervals: edoIntervals };
                state.notesPerStringLimit = notesPerStringSelect.value;
                
                const rootFreq = midiToFrequency(48 + rootNoteIndex12);
                const rootEdoInfo = frequencyToEdoInfo(rootFreq);
                const rootStepInOctave = rootEdoInfo.stepInOctave;
                const scaleStepsInOctave = new Set(edoIntervals.map(i => (rootStepInOctave + i) % state.temperament));

                let allPossibleScaleNotes = [];
                for (let i = 0; i < state.strings.length; i++) {
                    for (let j = -1; j < state.frets; j++) {
                        const freq = calculateFrettedFrequency(i, j);
                        if (freq <= 0) continue;
                        const noteEdoInfo = frequencyToEdoInfo(freq);
                        if (noteEdoInfo && scaleStepsInOctave.has(noteEdoInfo.stepInOctave)) {
                            allPossibleScaleNotes.push({ string: i, fret: j, freq: freq });
                        }
                    }
                }

                if (state.notesPerStringLimit === 'all') {
                    state.notes = allPossibleScaleNotes;
                } else {
                    const limit = parseInt(state.notesPerStringLimit, 10);
                    const sortedScaleNotes = allPossibleScaleNotes.sort((a, b) => a.freq - b.freq);
                    let startIndex = -1;
                    for (let i = 0; i < sortedScaleNotes.length; i++) {
                        const noteEdoInfo = frequencyToEdoInfo(sortedScaleNotes[i].freq);
                        if (noteEdoInfo && noteEdoInfo.stepInOctave === rootStepInOctave) {
                            startIndex = i;
                            break;
                        }
                    }

                    if (startIndex === -1) {
                        const notesByString = sortedScaleNotes.reduce((acc, note) => { (acc[note.string] = acc[note.string] || []).push(note); return acc; }, {});
                        state.notes = Object.values(notesByString).flatMap(stringNotes => stringNotes.slice(0, limit));
                    } else {
                        const finalNotes = [];
                        const notesPerStringCount = {}; 
                        for (let i = startIndex; i < sortedScaleNotes.length; i++) {
                            const note = sortedScaleNotes[i];
                            notesPerStringCount[note.string] = notesPerStringCount[note.string] || 0;
                            if (notesPerStringCount[note.string] < limit) {
                                finalNotes.push(note);
                                notesPerStringCount[note.string]++;
                            }
                        }
                        state.notes = finalNotes;
                    }
                }
                renderApp();
            }
            function handleShowScale() {
                const rootNoteIndex = parseInt(rootNoteSelect.value);
                const scaleType = scaleTypeSelect.value;
                const edoIntervals = state.currentScaleDefs[scaleType];
                if (!edoIntervals) return;

                const rootNoteName = NOTE_NAMES[rootNoteIndex];
                let noteNames;
                if (state.temperament === 12) {
                    noteNames = edoIntervals.map(i => NOTE_NAMES[(rootNoteIndex + i) % 12]).join(' ¬∑ ');
                } else {
                    const rootFreq = midiToFrequency(48 + rootNoteIndex);
                    const rootEdoInfo = frequencyToEdoInfo(rootFreq);
                    const rootStepInOctave = rootEdoInfo.stepInOctave;
                    const edoData = EDO_SYSTEMS[state.temperament] || { names: [] };
                    noteNames = edoIntervals.map(i => edoData.names[(rootStepInOctave + i) % state.temperament] || '?').join(' ¬∑ ');
                }

                currentRootDisplay.textContent = `Root: ${rootNoteName}`;
                currentNotesDisplay.textContent = `Scale (${scaleType} in ${state.temperament}-EDO): ${noteNames}`;

                showScaleOnFretboard(rootNoteIndex, edoIntervals, scaleType);
                updateCircleOfFifths(rootNoteIndex, scaleType);
                updateScaleModesDisplay(scaleType, rootNoteIndex);
            }
            function handleRandomScale() { 
                const options = Array.from(scaleTypeSelect.options);
                if (options.length === 0) return;
                rootNoteSelect.selectedIndex = Math.floor(Math.random() * rootNoteSelect.options.length); 
                scaleTypeSelect.selectedIndex = Math.floor(Math.random() * options.length); 
                handleShowScale(); 
            }
            function handleShowAllNotes() { clearTheory(); let allNotes = []; for (let i = 0; i < state.strings.length; i++) { for (let j = -1; j < state.frets; j++) { allNotes.push({string: i, fret: j}); } } state.notes = allNotes; renderApp(); }
            function clearTheory(clearDisplays = true) {
                state.notes = [];
                state.currentChord = null;
                state.currentScale = null;
                if (clearDisplays) {
                    updateCircleOfFifths(null);
                    updateScaleModesDisplay();
                    currentRootDisplay.textContent = '';
                    currentNotesDisplay.textContent = '';
                }
                renderApp();
            }
            function handleSetupChange(e) {
                TabEditor.stop();
                const setup = e.target.value;
                if (!setup) return;
                
                state.instrumentMode = null;
                
                clearTheory();
                switch (setup) {
                    case 'guitar': setTuning(6, 12, GUITAR_TUNING_HZ, GUITAR_GAUGES, 12); break;
                    case 'bass': setTuning(4, 20, BASS_TUNING_HZ, BASS_GAUGES, 12); break;
                    case 'ukulele': setTuning(4, 12, UKULELE_TUNING_HZ, UKULELE_GAUGES, 12); break;
                    case 'drop_d': setTuning(6, 12, DROP_D_TUNING_HZ, DROP_D_GAUGES, 12); break;
                    case 'open_g': setTuning(6, 12, OPEN_G_TUNING_HZ, OPEN_G_GAUGES, 12); break;
                    case 'dadgad': setTuning(6, 12, DADGAD_TUNING_HZ, DADGAD_GAUGES, 12); break;
                    case '7_string': setTuning(7, 24, SEVEN_STRING_TUNING_HZ, SEVEN_STRING_GAUGES, 12); break;
                    case '8_string': setTuning(8, 24, EIGHT_STRING_TUNING_HZ, EIGHT_STRING_GAUGES, 12); break;
                    case 'just_intonation': setTuning(6, 12, GUITAR_TUNING_HZ, GUITAR_GAUGES, 'just'); break;
                    case 'true_temperament': setTuning(6, 12, GUITAR_TUNING_HZ, GUITAR_GAUGES, 'true_temperament'); break;
                    case '19_edo': setTuning(6, 19, GUITAR_TUNING_HZ, GUITAR_GAUGES, 19); break;
                    case '24_edo': setTuning(6, 24, GUITAR_TUNING_HZ, GUITAR_GAUGES, 24); break;
                    case '31_edo': setTuning(6, 31, GUITAR_TUNING_HZ, GUITAR_GAUGES, 31); break;
                    case 'kantele_5_major': setTuning(5, 0, KANTELE_5_MAJOR_HZ, KANTELE_5_GAUGES, 12); break;
                    case 'kantele_5_minor': setTuning(5, 0, KANTELE_5_MINOR_HZ, KANTELE_5_MINOR_GAUGES, 12); break;
                    case 'kantele_11': setTuning(11, 0, KANTELE_11_HZ, KANTELE_11_GAUGES, 12); break;
                    case 'overtone': setupOvertoneSeries(); break;
                }
                updateTheoryDefinitions();
                TabEditor.init();
                renderApp();
                e.target.value = "";
            }
            function setTuning(numStrings, numFrets, tuningHz, gauges, temperamentSystem = 12) { 
                state.frets = numFrets; 
                state.strings = Array.from({ length: numStrings }, (_, i) => createStringWithTuning(tuningHz[i], gauges[i]));
                state.temperament = (typeof temperamentSystem === 'number') ? temperamentSystem : 12;
                generateInitialFretPositions(temperamentSystem); 
            }
            function setupOvertoneSeries() {
                const fundamentalHz = 110.00; // A2
                const numStrings = 8;
                const OVERTONE_BASE_GAUGE = 0.011;
                const OVERTONE_BASE_TENSION = 15.0;

                let newStrings = [];
                for (let i = 0; i < numStrings; i++) {
                    const harmonic = i + 1;
                    const freq = fundamentalHz * harmonic;
                    const len = calculateLength(OVERTONE_BASE_TENSION, OVERTONE_BASE_GAUGE, freq);
                    newStrings.push({ length: len, width: OVERTONE_BASE_GAUGE, tension: OVERTONE_BASE_TENSION });
                }
                state.strings = newStrings;
                state.frets = 0;
                state.instrumentMode = 'overtone';
                state.overtoneFundamentalHz = fundamentalHz;
                generateInitialFretPositions();
                TabEditor.init();
            }
            function handleReverseView() { state.isPlayerView = !state.isPlayerView; renderApp(); }
            function handleLeftHandedToggle() { state.isLeftHanded = !state.isLeftHanded; renderApp(); }
            function handleInteractionChange(e) {
                state.interactionMode = e.target.value;
                updateFretboardModeClass();
            }
            function updateFretboardModeClass() {
                fretboardContainer.classList.remove('mode-toggle_note', 'mode-insert', 'mode-remove', 'mode-play', 'mode-move_fret');
                fretboardContainer.classList.add(`mode-${state.interactionMode}`);
            }

            // --- Note Playback & Animation ---
            function playNoteSequenceWithAnimation(notes, delay) {
                if (!notes || notes.length === 0) return;
                notes.forEach((note, i) => {
                    setTimeout(() => {
                        const freq = calculateFrettedFrequency(note.string, note.fret);
                        if (freq > 0) AudioPlayer.playNote(freq, 0);
                        const fretSpaceEl = document.querySelector(`.fret-space[data-string-index='${note.string}'][data-fret-index='${note.fret}']`);
                        if (fretSpaceEl) {
                            fretSpaceEl.classList.add('note-playing');
                            setTimeout(() => fretSpaceEl.classList.remove('note-playing'), 300);
                        }
                    }, i * delay);
                });
            }
            function handlePlayStrum() {
                if (state.notes.length === 0) return;
                const notesByString = new Map();
                state.notes.forEach(note => {
                    if (!notesByString.has(note.string) || note.fret > notesByString.get(note.string).fret) {
                        notesByString.set(note.string, note);
                    }
                });
                const strumNotes = Array.from(notesByString.values()).sort((a, b) => a.string - b.string);
                playNoteSequenceWithAnimation(strumNotes, 50);
            }
            function handlePlayShred() {
                if (state.notes.length === 0) return;
                const shredNotes = [...state.notes].sort((a, b) => {
                    if (a.string !== b.string) return a.string - b.string;
                    return a.fret - b.fret;
                });
                playNoteSequenceWithAnimation(shredNotes, 80);
            }

            // --- STATE MODIFICATION ---
            function addNote(string, fretIndex) { state.notes.push({ string: string, fret: fretIndex }); renderApp(); }
            function removeNote(string, fretIndex) { state.notes = state.notes.filter(n => !(n.string === string && n.fret === fretIndex)); renderApp(); }
            function addString(location) {
                if (state.strings.length >= MAX_STRINGS) return;
                TabEditor.stop();
                
                if (location === 'high' && state.instrumentMode === 'overtone') {
                    const numStrings = state.strings.length;
                    const newHarmonic = numStrings + 1;
                    const newFreq = state.overtoneFundamentalHz * newHarmonic;
                    const baseTension = state.strings[0].tension;
                    const baseWidth = state.strings[0].width;
                    const newLength = calculateLength(baseTension, baseWidth, newFreq);
                    const newString = { length: newLength, width: baseWidth, tension: baseTension };
                    state.strings.push(newString);
                } else {
                    state.instrumentMode = null;
                    const isLow = location === 'low';
                    if (state.strings.length === 0) {
                        state.strings.push(createStringWithTuning(82.41, 0.042));
                    } else {
                        const semitoneShift = isLow ? -5 : 5;
                        const gaugeRatio = isLow ? 1.3 : 1 / 1.3;
                        const refIndex = isLow ? 0 : state.strings.length - 1;
                        const refString = state.strings[refIndex];
                        const refFreq = calculateFrequency(refString);
                        const newFreq = refFreq * Math.pow(2, semitoneShift / 12);
                        const newGauge = refString.width * gaugeRatio;
                        const newString = createStringWithTuning(newFreq, newGauge);
                        if (isLow) {
                            state.strings.unshift(newString);
                            if (state.currentChord || state.currentScale) clearTheory();
                            state.notes.forEach(n => n.string++);
                        } else {
                            state.strings.push(newString);
                        }
                    }
                }
                
                generateInitialFretPositions();
                TabEditor.init();
                renderApp();
            }
            function removeString(indexToRemove) { if (state.strings.length <= MIN_STRINGS) return; TabEditor.stop(); clearTheory(); state.strings.splice(indexToRemove, 1); state.fretPositions.splice(indexToRemove, 1); state.notes = state.notes.filter(n => n.string !== indexToRemove).map(n => { if (n.string > indexToRemove) n.string--; return n; }); state.instrumentMode = null; TabEditor.init(); renderApp(); }
            function changeFrets(amount) { const newCount = state.frets + amount; if (newCount >= MIN_FRETS && newCount <= MAX_FRETS) { clearTheory(); state.frets = newCount; generateInitialFretPositions(state.temperament); renderApp(); } }
            
            // --- THEORY DISPLAY (CIRCLE/MODES/PIE) ---
            function createModePieChart(steps) {
                const size = 40, radius = size / 2;
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', size); svg.setAttribute('height', size); svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
                let startAngle = -90;
                function polarToCartesian(cx, cy, r, angle) { return { x: cx + r * Math.cos((angle) * Math.PI / 180), y: cy + r * Math.sin((angle) * Math.PI / 180) }; }
                const totalSteps = steps.reduce((a, b) => a + b, 0);
                if (totalSteps === 0) return svg;
                steps.forEach(step => {
                    const sliceAngle = (step / totalSteps) * 360;
                    const endAngle = startAngle + sliceAngle;
                    const start = polarToCartesian(radius, radius, radius, startAngle);
                    const end = polarToCartesian(radius, radius, radius, endAngle);
                    const largeArcFlag = sliceAngle > 180 ? '1' : '0';
                    const d = `M ${radius},${radius} L ${start.x},${start.y} A ${radius},${radius} 0 ${largeArcFlag} 1 ${end.x},${end.y} Z`;
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', d);
                    let color = '#888'; // Default for other steps
                    if (step === 1) color = '#555';
                    if (step === 2) color = '#ddd';
                    if (step === 3) color = '#a0522d'; // Sienna brown
                    if (step === 4) color = '#8B4513'; // Saddle brown
                    path.setAttribute('fill', color);
                    path.setAttribute('stroke', '#333');
                    path.setAttribute('stroke-width', '0.5');
                    svg.appendChild(path);
                    startAngle = endAngle;
                });
                return svg;
            }
            function createCircleOfFifths() { const centerX = 150, centerY = 150, radius = 120; for (let i = 0; i < 12; i++) { const pitchClass = (i * 7) % 12; const angle = (i * 30 - 90) * (Math.PI / 180); const x = centerX + radius * Math.cos(angle), y = centerY + radius * Math.sin(angle); const group = document.createElementNS('http://www.w3.org/2000/svg', 'g'); group.classList.add('cof-note-group'); group.setAttribute('data-pitch-class', pitchClass); group.id = `cof-note-${pitchClass}`; const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circle.setAttribute('cx', x); circle.setAttribute('cy', y); circle.setAttribute('r', 25); circle.classList.add('cof-note-circle'); const noteText = document.createElementNS('http://www.w3.org/2000/svg', 'text'); noteText.setAttribute('x', x); noteText.setAttribute('y', y - 5); noteText.classList.add('cof-note-text'); noteText.textContent = NOTE_NAMES[pitchClass]; const romanText = document.createElementNS('http://www.w3.org/2000/svg', 'text'); romanText.setAttribute('x', x); romanText.setAttribute('y', y + 8); romanText.classList.add('cof-roman-text'); group.appendChild(circle); group.appendChild(noteText); group.appendChild(romanText); group.addEventListener('click', handleCofClick); cofSvg.insertBefore(group, cofLockBtn); } }
            function updateCircleOfFifths(rootNoteIndex, scaleName = 'Major (Ionian)') {
                if(state.temperament !== 12) return;
                document.querySelectorAll('#cof-svg .cof-note-group').forEach(g => {
                    g.querySelector('.cof-note-circle').classList.remove('highlight');
                    g.querySelector('.cof-roman-text').textContent = '';
                });
                if (rootNoteIndex === null || rootNoteIndex === undefined) return;

                const scaleIntervals = state.currentScaleDefs[scaleName] || [];
                const isHeptatonic = scaleIntervals.length === 7;
                const diatonicChords = scaleName.includes('Minor') ? MINOR_SCALE_DIATONIC_CHORDS : MAJOR_SCALE_DIATONIC_CHORDS;
                
                scaleIntervals.forEach((interval, i) => {
                    const notePitchClass = (rootNoteIndex + interval) % 12;
                    const group = document.getElementById(`cof-note-${notePitchClass}`);
                    if (group) {
                        group.querySelector('.cof-note-circle').classList.add('highlight');
                        if (isHeptatonic) {
                            const romanText = group.querySelector('.cof-roman-text');
                            romanText.textContent = diatonicChords[i].roman;
                            group.dataset.chordType = diatonicChords[i].type;
                        }
                    }
                });
            }
            function handleCofClick(e) {
                const group = e.currentTarget;
                const pitchClass = parseInt(group.dataset.pitchClass);
                const chordType = group.dataset.chordType || 'Major';

                if (state.interactionMode === 'play') {
                    const rootMidi = 60 + pitchClass;
                    const chordSteps = CHORD_DEFINITIONS[chordType].steps;
                    const chordIntervals = chordStepsToAbsoluteIntervals(chordSteps);
                    const frequencies = chordIntervals.map(interval => midiToFrequency(rootMidi + interval));
                    AudioPlayer.playSequence(frequencies);
                    return;
                }

                if (!state.isRootLocked) {
                    rootNoteSelect.value = pitchClass;
                    chordTypeSelect.value = chordType;
                    handleShowChord();
                } else {
                    const voicing = findChordVoicing(pitchClass, chordType);
                    state.notes = voicing;
                    state.currentChord = { root: pitchClass, type: chordType, notes: voicing };
                    const lockedRootName = NOTE_NAMES[parseInt(rootNoteSelect.value)];
                    const clickedRootName = NOTE_NAMES[pitchClass];
                    const chordSteps = CHORD_DEFINITIONS[chordType].steps;
                    const chordIntervals = chordStepsToAbsoluteIntervals(chordSteps);
                    const chordNoteNames = chordIntervals.map(i => NOTE_NAMES[(pitchClass + i) % 12]).join(' ¬∑ ');
                    currentRootDisplay.textContent = `Key: ${lockedRootName} | Chord: ${clickedRootName} ${chordType}`;
                    currentNotesDisplay.textContent = `Notes: ${chordNoteNames}`;
                    renderApp();
                }
            }
            function handleLockToggle() { 
                state.isRootLocked = !state.isRootLocked; 
                const lockCircle = cofLockBtn.querySelector('circle'); 
                if (state.isRootLocked) { 
                    lockCircle.classList.add('locked'); 
                    cofLockIcon.textContent = 'üîí'; 
                } else { 
                    lockCircle.classList.remove('locked'); 
                    cofLockIcon.textContent = 'üîì'; 
                    if(state.currentScale) { handleShowScale() } 
                    else if(state.currentChord) { handleShowChord() } 
                } 
            }
            function updateScaleModesDisplay(parentScaleName, parentRootIndex) {
                scaleModesList.innerHTML = '';
                const parentIntervals = state.currentScaleDefs[parentScaleName];

                if (!parentScaleName || !parentIntervals || !state.scaleStepsToNameMap) {
                    scaleModesContainer.style.display = 'none';
                    return;
                }
                scaleModesContainer.style.display = 'flex';

                const rootFreq = midiToFrequency(48 + parentRootIndex);
                const rootEdoInfo = frequencyToEdoInfo(rootFreq);
                const rootStepInOctave = rootEdoInfo.stepInOctave;

                parentIntervals.forEach((interval, i) => {
                    const modeRootStep = (rootStepInOctave + interval) % state.temperament;
                    const modeRootName = (state.temperament === 12) 
                        ? NOTE_NAMES[(parentRootIndex + interval) % 12] 
                        : (EDO_SYSTEMS[state.temperament]?.names[modeRootStep] || `S:${modeRootStep}`);

                    const modeIntervals = parentIntervals.map(p_int => (p_int - interval + state.temperament) % state.temperament).sort((a, b) => a - b);
                    const modeSteps = modeIntervals.map((n, j) => {
                        const next = modeIntervals[j + 1] || (modeIntervals[0] + state.temperament);
                        return next - n;
                    });

                    const modeStepsKey = JSON.stringify(modeSteps);
                    const foundModeName = state.scaleStepsToNameMap.get(modeStepsKey);
                    
                    const modeNumberDisplay = i + 1;
                    const modeDisplayName = foundModeName || `${parentScaleName} Mode ${modeNumberDisplay}`;
                    
                    const li = document.createElement('li');
                    li.className = 'mode-item';
                    
                    const textContainer = document.createElement('div');
                    textContainer.className = 'mode-text-container';
                    textContainer.innerHTML = `<div class="mode-name">${DIATONIC_DEGREES[i] || i+1} - ${modeRootName} ${modeDisplayName}</div><div class="mode-steps">${modeSteps.join('-')}</div>`;
                    
                    const pieChartSvg = createModePieChart(modeSteps);
                    li.appendChild(pieChartSvg);
                    li.appendChild(textContainer);
                    
                    li.addEventListener('click', () => {
                        if (state.interactionMode === 'play') {
                            const modeRootFreq = rootFreq * Math.pow(2, interval / state.temperament);
                            const frequencies = modeIntervals.map(iv => modeRootFreq * Math.pow(2, iv / state.temperament));
                            AudioPlayer.playSequence(frequencies);
                            return;
                        }

                        if (foundModeName) {
                            const modeRootFreq = rootFreq * Math.pow(2, interval / state.temperament);
                            const newRootMidi = frequencyToMidi(modeRootFreq);
                            rootNoteSelect.value = newRootMidi % 12;
                            scaleTypeSelect.value = foundModeName;
                            handleShowScale();
                        }
                    });
                    scaleModesList.appendChild(li);
                });
            }

            // --- MIDI & KEYBOARD ---
            function initMidi() {
                if (navigator.requestMIDIAccess) {
                    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
                } else { console.warn("Web MIDI API not supported in this browser."); }
            }
            function onMIDISuccess(midiAccess) {
                state.midiAccess = midiAccess;
                state.midiInputs = Array.from(midiAccess.inputs.values());
                state.midiOutputs = Array.from(midiAccess.outputs.values());
                populateMidiDropdowns();
                midiAccess.onstatechange = onMIDIStateChange;
            }
            function onMIDIFailure() { console.error('Could not access your MIDI devices.'); }
            function onMIDIStateChange() {
                state.midiInputs = Array.from(state.midiAccess.inputs.values());
                state.midiOutputs = Array.from(state.midiAccess.outputs.values());
                populateMidiDropdowns();
            }
            function populateMidiDropdowns() {
                midiInSelect.innerHTML = '<option value="">None</option>';
                midiOutSelect.innerHTML = '<option value="">None</option>';
                state.midiInputs.forEach(input => midiInSelect.innerHTML += `<option value="${input.id}">${input.name}</option>`);
                state.midiOutputs.forEach(output => midiOutSelect.innerHTML += `<option value="${output.id}">${output.name}</option>`);
                midiInSelect.value = state.selectedMidiInId || "";
                midiOutSelect.value = state.selectedMidiOutId || "";
            }
            function handleMidiInChange(e) {
                const selectedId = e.target.value;
                if (state.selectedMidiInId) { const oldInput = state.midiAccess.inputs.get(state.selectedMidiInId); if (oldInput) oldInput.onmidimessage = null; }
                state.selectedMidiInId = selectedId;
                if (selectedId) { const newInput = state.midiAccess.inputs.get(selectedId); if (newInput) newInput.onmidimessage = handleMidiMessage; }
            }
            function handleMidiMessage(event) {
                const command = event.data[0] >> 4;
                const note = event.data[1];
                const velocity = event.data.length > 2 ? event.data[2] : 0;
                if (command === 9 && velocity > 0) { handleNoteOn(note, velocity); }
                else if (command === 8 || (command === 9 && velocity === 0)) { handleNoteOff(note); }
            }
            function handleNoteOn(midiNote, velocity) {
                if (state.activeMidiNotes.has(midiNote)) return;
                const location = findFirstAvailableNoteLocation(midiNote);
                if (location) {
                    const fretSpaceEl = document.querySelector(`.fret-space[data-string-index='${location.string}'][data-fret-index='${location.fret}']`);
                    if (fretSpaceEl) {
                        fretSpaceEl.classList.add('note-active');
                        state.activeMidiNotes.set(midiNote, fretSpaceEl);
                    }
                }
                AudioPlayer.playNote(midiToFrequency(midiNote), 0);
                if (state.selectedMidiOutId) { const output = state.midiAccess.outputs.get(state.selectedMidiOutId); if (output) output.send([0x90, midiNote, velocity]); }
            }
            function handleNoteOff(midiNote) {
                if (state.activeMidiNotes.has(midiNote)) {
                    const fretSpaceEl = state.activeMidiNotes.get(midiNote);
                    fretSpaceEl.classList.remove('note-active');
                    state.activeMidiNotes.delete(midiNote);
                }
                if (state.selectedMidiOutId) { const output = state.midiAccess.outputs.get(state.selectedMidiOutId); if (output) output.send([0x80, midiNote, 0]); }
            }
            function findFirstAvailableNoteLocation(midiNote) {
                for (let i = state.strings.length - 1; i >= 0; i--) {
                    const openStringMidi = frequencyToMidi(calculateFrequency(state.strings[i]));
                    const fret = midiNote - openStringMidi;
                    if (fret >= 0 && fret < state.frets) {
                        return { string: i, fret: fret };
                    }
                }
                return null;
            }
            function handleKeyDown(e) {
                if(document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;
                if (TabEditor.handleKeyDown(e)) {
                    return; 
                }
                const midiNote = KEYBOARD_MAP[e.key];
                if (midiNote && !state.activeMidiNotes.has(midiNote)) {
                    handleNoteOn(midiNote, 100);
                }
            }
            function handleKeyUp(e) { if(document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; const midiNote = KEYBOARD_MAP[e.key]; if (midiNote) { handleNoteOff(midiNote); } }

            // --- UI UPDATE & INITIALIZATION ---
            function updateTheoryDefinitions() {
                // Chord definitions are simpler and can stay as they are, just combining based on EDO.
                let chordDefs = { ...CHORD_DEFINITIONS };
                if (state.temperament === 19) chordDefs = { ...chordDefs, ...CHORD_DEFINITIONS_19 };
                if (state.temperament === 24) chordDefs = { ...chordDefs, ...CHORD_DEFINITIONS_24 };
                if (state.temperament === 31) chordDefs = { ...chordDefs, ...CHORD_DEFINITIONS_31 };
                state.currentChordDefs = chordDefs;

                // Build scale definitions and the step-to-name reverse map
                const finalScaleDefs = {};
                const stepsToNameMap = new Map();
                const source12EDOScales = state.isZeitlerMode ? ZEITLER_SCALE_DEFINITIONS : SCALE_DEFINITIONS;

                const processScaleSet = (scaleSet) => {
                    for (const scaleName in scaleSet) {
                        const steps = scaleSet[scaleName];
                        finalScaleDefs[scaleName] = stepsToIntervals(steps);
                        const stepsKey = JSON.stringify(steps);
                        if (!stepsToNameMap.has(stepsKey)) {
                            stepsToNameMap.set(stepsKey, scaleName);
                        }
                    }
                };

                if (state.temperament === 12) {
                    processScaleSet(source12EDOScales);
                } else {
                    // Map the standard 12-EDO scales to the current EDO
                    for (const scaleName in source12EDOScales) {
                        const steps = source12EDOScales[scaleName];
                        let convertedSteps = steps.map(s => Math.round(s * (state.temperament / 12.0)));
                        const sumOfSteps = convertedSteps.reduce((a, b) => a + b, 0);

                        // Correct for rounding errors to ensure the scale sums to the EDO
                        if (sumOfSteps !== state.temperament) {
                            const diff = state.temperament - sumOfSteps;
                            convertedSteps[convertedSteps.length - 1] += diff;
                        }
                        
                        const newName = `${scaleName} (‚Üí${state.temperament}EDO)`;
                        finalScaleDefs[newName] = stepsToIntervals(convertedSteps);
                        stepsToNameMap.set(JSON.stringify(convertedSteps), newName);
                    }
                }

                // Add the hardcoded, native scales for the current EDO, overwriting any mappings
                const edoSpecificScales = { 19: SCALE_DEFINITIONS_19, 24: SCALE_DEFINITIONS_24, 31: SCALE_DEFINITIONS_31 };
                if (edoSpecificScales[state.temperament]) {
                    processScaleSet(edoSpecificScales[state.temperament]);
                }

                state.currentScaleDefs = finalScaleDefs;
                state.scaleStepsToNameMap = stepsToNameMap;
                populateTheoryDropdowns();
            }

            function updateScaleDropdown() {
                const searchTerm = scaleSearchInput.value.toLowerCase();
                const selectedScale = scaleTypeSelect.value;
                
                scaleTypeSelect.innerHTML = '';
                Object.keys(state.currentScaleDefs).sort().forEach(name => {
                    if (name.toLowerCase().includes(searchTerm)) {
                        scaleTypeSelect.innerHTML += `<option value="${name}">${name}</option>`;
                    }
                });

                if (Array.from(scaleTypeSelect.options).some(opt => opt.value === selectedScale)) {
                    scaleTypeSelect.value = selectedScale;
                }
            }

            function populateTheoryDropdowns() {
                const selectedChord = chordTypeSelect.value;
                chordTypeSelect.innerHTML = '';
                Object.keys(state.currentChordDefs).sort().forEach(name => {
                    chordTypeSelect.innerHTML += `<option value="${name}">${name}</option>`;
                });
                if (Array.from(chordTypeSelect.options).some(opt => opt.value === selectedChord)) {
                    chordTypeSelect.value = selectedChord;
                }
                updateScaleDropdown();
            }

            function populateRootDropdown() {
                rootNoteSelect.innerHTML = '';
                NOTE_NAMES.forEach((name, i) => rootNoteSelect.innerHTML += `<option value="${i}">${name}</option>`);
            }
            function updateGlobalControls() { 
                fretCountEl.textContent = state.frets; 
                addHighStringBtn.disabled = state.strings.length >= MAX_STRINGS; 
                addLowStringBtn.disabled = state.strings.length >= MAX_STRINGS || state.instrumentMode === 'overtone';
                removeFretBtn.disabled = state.frets <= MIN_FRETS; 
                addFretBtn.disabled = state.frets >= MAX_FRETS; 
                showFretNumbersBtn.textContent = state.showFretNumbers ? 'Hide Fret #' : 'Show Fret #'; 
                reverseStringsBtn.textContent = state.isPlayerView ? 'Spectator View' : 'Player View';
                
                // Update Left Handed button text based on player and spectator views
                const baseLhText = state.isLeftHanded ? 'Right Handed' : 'Left Handed';
                if (!state.isPlayerView) { // In Spectator View, the perspective is flipped
                    leftHandedBtn.textContent = (baseLhText === 'Right Handed') ? 'Left Handed' : 'Right Handed';
                } else {
                    leftHandedBtn.textContent = baseLhText;
                }

                document.querySelectorAll('.remove-string-btn').forEach(btn => btn.disabled = (state.strings.length <= MIN_STRINGS)); 
            }

            // Event Listeners
            addLowStringBtn.addEventListener('click', () => addString('low')); addHighStringBtn.addEventListener('click', () => addString('high')); addFretBtn.addEventListener('click', () => changeFrets(1)); removeFretBtn.addEventListener('click', () => changeFrets(-1));
            resetFretsBtn.addEventListener('click', () => { TabEditor.stop(); clearTheory(); state.instrumentMode = null; setTuning(6, 12, GUITAR_TUNING_HZ, GUITAR_GAUGES, 12); updateTheoryDefinitions(); TabEditor.init(); renderApp(); });
            toggleTuningBtn.addEventListener('click', () => { state.tuningPanelVisible = !state.tuningPanelVisible; renderApp(); });
            displayModeSelect.addEventListener('change', (e) => { state.noteDisplayMode = e.target.value; renderApp(); });
            showChordBtn.addEventListener('click', handleShowChord); clearFretboardBtn.addEventListener('click', () => clearTheory(true));
            playStrumBtn.addEventListener('click', handlePlayStrum);
            playShredBtn.addEventListener('click', handlePlayShred);
            showScaleBtn.addEventListener('click', handleShowScale); randomScaleBtn.addEventListener('click', handleRandomScale);
            showAllNotesBtn.addEventListener('click', handleShowAllNotes);
            showFretNumbersBtn.addEventListener('click', () => { state.showFretNumbers = !state.showFretNumbers; renderApp(); });
            reverseStringsBtn.addEventListener('click', handleReverseView);
            leftHandedBtn.addEventListener('click', handleLeftHandedToggle);
            editPlayModeSelect.addEventListener('change', handleInteractionChange);
            midiInSelect.addEventListener('change', handleMidiInChange);
            midiOutSelect.addEventListener('change', e => { state.selectedMidiOutId = e.target.value; });
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            notesPerStringSelect.addEventListener('change', (e) => { if (state.currentScale) { handleShowScale(); } });
            setupSelect.addEventListener('change', handleSetupChange);
            cofLockBtn.addEventListener('click', handleLockToggle);
            zoomSlider.addEventListener('input', e => { fretboardWrapper.style.width = `${100 + e.target.value * 2}%`; });
            masterVolumeSlider.addEventListener('input', e => { 
                const newVolume = parseFloat(e.target.value) / 100;
                state.masterVolume = newVolume;
                AudioPlayer.init();
                AudioPlayer.setVolume(newVolume);
            });
            toggleScaleSetBtn.addEventListener('click', () => {
                state.isZeitlerMode = !state.isZeitlerMode;
                toggleScaleSetBtn.textContent = state.isZeitlerMode ? 'Show Basic Scales' : 'Show Zeitler Scales';
                zeitlerCredit.style.display = state.isZeitlerMode ? 'block' : 'none';
                updateTheoryDefinitions();
            });
            scaleSearchInput.addEventListener('input', updateScaleDropdown);
            soundTypeSelect.addEventListener('change', (e) => {
                AudioPlayer.setSoundType(e.target.value);
                // Play a test note to confirm the sound change
                AudioPlayer.playNote(midiToFrequency(60), 0); // Play a C4
            });
            
            // --- INITIALIZATION ---
            JSON.parse(ZEITLER_SCALES_RAW).forEach(scale => {
                ZEITLER_SCALE_DEFINITIONS[scale.name] = scale.steps;
            });
            
            const all12EDOScaleSteps = { ...SCALE_DEFINITIONS, ...ZEITLER_SCALE_DEFINITIONS };
            for(const scaleName in all12EDOScaleSteps) {
                ALL_SCALE_DEFINITIONS_FOR_RECOGNITION[scaleName] = stepsToIntervals(all12EDOScaleSteps[scaleName]);
            }
            
            populateRootDropdown();
            createCircleOfFifths();
            initMidi();
            setTuning(6, 12, GUITAR_TUNING_HZ, GUITAR_GAUGES, 12); 
            updateTheoryDefinitions();

            TabEditor.setup({
                state: state,
                dom: { 
                    tabGrid, tabPlayhead, tempoInput, textTabIo, midiFileInput, playTabBtn, 
                    stopTabBtn, addTabColBtn, removeTabColBtn, importTextTabBtn, 
                    exportTextTabBtn, exportMidiBtn 
                },
                helpers: { 
                    calculateFrettedFrequency, frequencyToNoteName, frequencyToEdoInfo,
                    frequencyToMidi, findFirstAvailableNoteLocation
                },
                audio: AudioPlayer
            });
            
            renderApp();
            AudioPlayer.init();
        });
    </script>
</body>
</html>
